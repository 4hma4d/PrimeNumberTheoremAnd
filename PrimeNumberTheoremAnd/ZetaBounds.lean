import Mathlib.Analysis.Calculus.ContDiff.Defs
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.NumberTheory.ZetaFunction
import Mathlib.Algebra.Group.Basic
import EulerProducts.PNT
import PrimeNumberTheoremAnd.ResidueCalcOnRectangles
import PrimeNumberTheoremAnd.MellinCalculus
import Mathlib.MeasureTheory.Function.Floor
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.NumberTheory.Harmonic.Bounds

-- only importing the following for the MeasurableDiv‚ÇÇ ‚Ñù instance.
-- should remove eventually
import PrimeNumberTheoremAnd.PerronFormula

-- set_option quotPrecheck false
open BigOperators Complex Topology Filter Interval Set

lemma div_cpow_eq_cpow_neg (a x s : ‚ÑÇ) : a / x ^ s = a * x ^ (-s) := by
  rw [div_eq_mul_inv, cpow_neg]

lemma one_div_cpow_eq_cpow_neg (x s : ‚ÑÇ) : 1 / x ^ s = x ^ (-s) := by
  convert div_cpow_eq_cpow_neg 1 x s using 1; simp

lemma div_rpow_eq_rpow_neg (a x s : ‚Ñù) (hx : 0 ‚â§ x): a / x ^ s = a * x ^ (-s) := by
  rw [div_eq_mul_inv, Real.rpow_neg hx]

lemma div_rpow_neg_eq_rpow_div {x y s : ‚Ñù} (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) :
    x ^ (-s) / y ^ (-s) = (y / x) ^ s := by
  rw [div_eq_mul_inv, Real.rpow_neg hx, Real.rpow_neg hy, Real.div_rpow hy hx]; field_simp

lemma div_rpow_eq_rpow_div_neg {x y s : ‚Ñù} (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) :
    x ^ s / y ^ s = (y / x) ^ (-s) := by
  convert div_rpow_neg_eq_rpow_div (s := -s) hx hy using 1; simp only [neg_neg]

/-%%
\begin{definition}[RiemannZeta0]\label{RiemannZeta0}\lean{RiemannZeta0}\leanok
\uses{ZetaSum_aux2}
For any natural $N\ge1$, we define
$$
\zeta_0(N,s) :=
\sum_{1\le n < N} \frac1{n^s}
+
\frac{- N^{1-s}}{1-s} + \frac{-N^{-s}}{2} + s \int_N^\infty \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx
$$
\end{definition}
%%-/
noncomputable def riemannZeta0 (N : ‚Ñï) (s : ‚ÑÇ) : ‚ÑÇ :=
  (‚àë n in Finset.range N, 1 / (n : ‚ÑÇ) ^ s) +
  (- N ^ (1 - s)) / (1 - s) + (- N ^ (-s)) / 2
      + s * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)

/-- We use `Œ∂` to denote the Rieman zeta function and `Œ∂‚ÇÄ` to denote the alternative
  Rieman zeta function.. -/
local notation (name := riemannzeta) "Œ∂" => riemannZeta
local notation (name := riemannzeta0) "Œ∂‚ÇÄ" => riemannZeta0

lemma riemannZeta0_apply (N : ‚Ñï) (s : ‚ÑÇ) : Œ∂‚ÇÄ N s =
    (‚àë n in Finset.range N, 1 / (n : ‚ÑÇ) ^ s) +
    ((- N ^ (1 - s)) / (1 - s) + (- N ^ (-s)) / 2
      + s * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(s + 1))) := by
  simp_rw [riemannZeta0, div_cpow_eq_cpow_neg]; ring

-- lemma AnalyticContinuation {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {s t : Set ‚ÑÇ} (f_on_s : AnalyticOn ‚ÑÇ f s)
--     (g_on_t : AnalyticOn ‚ÑÇ g t) (f_eq_g_on_cap : EqOn f g (s ‚à© t))
--     (s_open : IsOpen s) (t_open : IsOpen t) (cap_nonempty : Nonempty (s ‚à© t)) :
--     ‚àÉ! h : ‚ÑÇ ‚Üí ‚ÑÇ, AnalyticOn ‚ÑÇ h (s ‚à™ t) ‚àß EqOn h f s ‚àß EqOn h g t := by
--   classical
--   let h : ‚ÑÇ ‚Üí ‚ÑÇ := fun z ‚Ü¶ if z ‚àà s then f z else g z
--   refine ‚ü®h, ‚ü®?_, fun z hz ‚Ü¶ by simp [h, hz], ?_‚ü©, ?_‚ü©
--   ¬∑ sorry
--   ¬∑ intro z hz
--     by_cases z_in_s : z ‚àà s
--     ¬∑ have : z ‚àà s ‚à© t := by simp [z_in_s, hz]
--       have := f_eq_g_on_cap this
--       simp [h, z_in_s, this]
--     ¬∑ simp [h, z_in_s]
--   ¬∑ intro h' ‚ü®h'_analytic, h'_eq_f_on_s, h'_eq_g_on_t‚ü©
--     sorry

-- lemma AnalyticContinuation' {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {s t u : Set ‚ÑÇ} (f_on_s : AnalyticOn ‚ÑÇ f s)
--     (g_on_t : AnalyticOn ‚ÑÇ g t) (u_sub : u ‚äÜ s ‚à© t) (u_open : IsOpen u)
--     (u_nonempty : Nonempty u) (f_eq_g_on_u : EqOn f g u) :
--     EqOn f g (s ‚à© t) := by
--   sorry

-- move near `Real.differentiableAt_rpow_const_of_ne`
lemma Real.differentiableAt_cpow_const_of_ne (s : ‚ÑÇ) {x : ‚Ñù} (xpos : 0 < x) :
    DifferentiableAt ‚Ñù (fun (x : ‚Ñù) ‚Ü¶ (x : ‚ÑÇ) ^ s) x := by
  apply DifferentiableAt.comp_ofReal (e := fun z ‚Ü¶ z ^ s)
  apply DifferentiableAt.cpow (by simp) (by simp) (by simp [xpos])

lemma Complex.one_div_cpow_eq {s : ‚ÑÇ} {x : ‚Ñù} (x_ne : x ‚â† 0) :
    1 / (x : ‚ÑÇ) ^ s = (x : ‚ÑÇ) ^ (-s) := by
  refine (eq_one_div_of_mul_eq_one_left ?_).symm
  rw [‚Üê cpow_add _ _ <| mod_cast x_ne, add_left_neg, cpow_zero]

-- No longer used
lemma ContDiffOn.hasDeriv_deriv {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {s : Set ‚Ñù} (œÜDiff : ContDiffOn ‚Ñù 1 œÜ s) {x : ‚Ñù}
    (x_in_s : s ‚àà nhds x) : HasDerivAt œÜ (deriv œÜ x) x :=
  (ContDiffAt.hasStrictDerivAt (œÜDiff.contDiffAt x_in_s) (by simp)).hasDerivAt

-- No longer used
lemma ContDiffOn.continuousOn_deriv {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù}
    (œÜDiff : ContDiffOn ‚Ñù 1 œÜ (uIoo a b)) :
    ContinuousOn (deriv œÜ) (uIoo a b) := by
  apply ContDiffOn.continuousOn (ùïú := ‚Ñù) (n := 0)
  exact (fun h ‚Ü¶ ((contDiffOn_succ_iff_deriv_of_isOpen isOpen_Ioo).1 h).2) œÜDiff

lemma LinearDerivative_ofReal (x : ‚Ñù) (a b : ‚ÑÇ) : HasDerivAt (fun (t : ‚Ñù) ‚Ü¶ a * t + b) a x := by
  refine HasDerivAt.add_const ?_ b
  convert (ContinuousLinearMap.hasDerivAt Complex.ofRealCLM).const_mul a using 1; simp
-- No longer used
section
-- from Floris van Doorn

variable {A : Type*} [NormedRing A] [NormedAlgebra ‚Ñù A] [CompleteSpace A] {a b : ‚Ñù}

set_option autoImplicit false in
open BigOperators Interval Topology Set intervalIntegral MeasureTheory in
lemma integral_deriv_mul_eq_sub' {u v u' v' : ‚Ñù ‚Üí A}
    (hu : ‚àÄ x ‚àà [[a, b]], HasDerivWithinAt u (u' x) [[a, b]] x)
    (hv : ‚àÄ x ‚àà [[a, b]], HasDerivWithinAt v (v' x) [[a, b]] x)
    (hu' : IntervalIntegrable u' volume a b)
    (hv' : IntervalIntegrable v' volume a b) :
    ‚à´ x in a..b, u' x * v x + u x * v' x = u b * v b - u a * v a := by
  have h2u : ContinuousOn u [[a, b]] := fun x hx ‚Ü¶ (hu x hx).continuousWithinAt
  have h2v : ContinuousOn v [[a, b]] := fun x hx ‚Ü¶ (hv x hx).continuousWithinAt
  apply integral_eq_sub_of_hasDeriv_right (h2u.mul h2v)
  ¬∑ exact fun x hx ‚Ü¶ (hu x <| mem_Icc_of_Ioo hx).mul (hv x <| mem_Icc_of_Ioo hx) |>.hasDerivAt
      (Icc_mem_nhds hx.1 hx.2) |>.hasDerivWithinAt
  ¬∑ exact (hu'.mul_continuousOn h2v).add (hv'.continuousOn_mul h2u)

end

lemma sum_eq_int_deriv_aux2 {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} (c : ‚ÑÇ)
    (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚à´ (x : ‚Ñù) in a..b, (c - x) * deriv œÜ x =
      (c - b) * œÜ b - (c - a) * œÜ a + ‚à´ (x : ‚Ñù) in a..b, œÜ x := by
  set u := fun (x : ‚Ñù) ‚Ü¶ c - x
  set u' := fun (x : ‚Ñù) ‚Ü¶ (-1 : ‚ÑÇ)
  have hu : ‚àÄ x ‚àà uIcc a b, HasDerivAt u (u' x) x := by
    exact fun x _ ‚Ü¶ by convert LinearDerivative_ofReal x (-1 : ‚ÑÇ) c; ring
  have hu' : IntervalIntegrable u' MeasureTheory.volume a b := by
    apply Continuous.intervalIntegrable; continuity
  have hv' : IntervalIntegrable (deriv œÜ) MeasureTheory.volume a b :=
    derivœÜCont.intervalIntegrable
  convert intervalIntegral.integral_mul_deriv_eq_deriv_mul hu œÜDiff hu' hv' using 1; simp [u]

lemma sum_eq_int_deriv_aux_eq {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} {k : ‚Ñ§}
    (b_eq_kpOne : b = k + 1) (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚àë n in Finset.Ioc k ‚åäb‚åã, œÜ n =
    (‚à´ x in a..b, œÜ x) + (‚åäb‚åã + 1 / 2 - b) * œÜ b - (k + 1 / 2 - a) * œÜ a
      - ‚à´ x in a..b, (k + 1 / 2 - x) * deriv œÜ x := by
  have flb_eq_k : ‚åäb‚åã = k + 1 := Int.floor_eq_iff.mpr ‚ü®by exact_mod_cast b_eq_kpOne.symm.le,
    by rw [b_eq_kpOne]; simp‚ü©
  simp only [flb_eq_k, Finset.Icc_self, Finset.sum_singleton, Int.cast_add, Int.cast_one]
  rw [sum_eq_int_deriv_aux2 (k + 1 / 2) œÜDiff derivœÜCont, b_eq_kpOne]
  ring_nf
  have : Finset.Ioc k (1 + k) = {k + 1} := by
    ext m
    simp only [Finset.mem_Ioc, Finset.mem_singleton]
    constructor
    ¬∑ exact fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ by rw [add_comm] at h‚ÇÇ; exact Int.le_antisymm h‚ÇÇ h‚ÇÅ
    ¬∑ exact fun h ‚Ü¶ ‚ü®by simp [h], by simp [h, add_comm]‚ü©
  simp_rw [this, Finset.sum_singleton, Int.cast_add, Int.cast_one, add_comm]

lemma sum_eq_int_deriv_aux_lt {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} {k : ‚Ñ§} (ha : a ‚àà Ico (k : ‚Ñù) b)
    (b_lt_kpOne : b < k + 1) (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚àë n in Finset.Ioc k ‚åäb‚åã, œÜ n =
    (‚à´ x in a..b, œÜ x) + (‚åäb‚åã + 1 / 2 - b) * œÜ b - (k + 1 / 2 - a) * œÜ a
      - ‚à´ x in a..b, (k + 1 / 2 - x) * deriv œÜ x := by
  have flb_eq_k : ‚åäb‚åã = k := Int.floor_eq_iff.mpr ‚ü®by linarith [ha.1, ha.2], by linarith‚ü©
  simp only [flb_eq_k, gt_iff_lt, lt_add_iff_pos_right, zero_lt_one, Finset.Icc_eq_empty_of_lt,
    Finset.sum_empty]
  rw [sum_eq_int_deriv_aux2 (k + 1 / 2) œÜDiff derivœÜCont]
  have : Finset.Ioc k k = {} := by simp only [ge_iff_le, le_refl, Finset.Ioc_eq_empty_of_le]
  simp only [this, Finset.sum_empty, one_div]; ring_nf

lemma sum_eq_int_deriv_aux1 {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} {k : ‚Ñ§} (ha : a ‚àà Ico (k : ‚Ñù) b)
    (b_le_kpOne : b ‚â§ k + 1) (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚àë n in Finset.Ioc k ‚åäb‚åã, œÜ n =
    (‚à´ x in a..b, œÜ x) + (‚åäb‚åã + 1 / 2 - b) * œÜ b - (k + 1 / 2 - a) * œÜ a
      - ‚à´ x in a..b, (k + 1 / 2 - x) * deriv œÜ x := by
  by_cases h : b = k + 1
  ¬∑ exact sum_eq_int_deriv_aux_eq h œÜDiff derivœÜCont
  ¬∑ exact sum_eq_int_deriv_aux_lt ha (Ne.lt_of_le h b_le_kpOne) œÜDiff derivœÜCont

/-%%
\begin{lemma}[sum_eq_int_deriv_aux]\label{sum_eq_int_deriv_aux}\lean{sum_eq_int_deriv_aux}\leanok
  Let $k \le a < b\le k+1$, with $k$ an integer, and let $\phi$ be continuously differentiable on
  $[a, b]$.
  Then
  \[
  \sum_{a < n \le b} \phi(n) = \int_a^b \phi(x) \, dx + \left(\lfloor b \rfloor + \frac{1}{2} - b\right) \phi(b) - \left(\lfloor a \rfloor + \frac{1}{2} - a\right) \phi(a) - \int_a^b \left(\lfloor x \rfloor + \frac{1}{2} - x\right) \phi'(x) \, dx.
  \]
\end{lemma}
%%-/
lemma sum_eq_int_deriv_aux {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} {k : ‚Ñ§} (ha : a ‚àà Ico (k : ‚Ñù) b)
    (b_le_kpOne : b ‚â§ k + 1) (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚àë n in Finset.Ioc ‚åäa‚åã ‚åäb‚åã, œÜ n =
    (‚à´ x in a..b, œÜ x) + (‚åäb‚åã + 1 / 2 - b) * œÜ b - (‚åäa‚åã + 1 / 2 - a) * œÜ a
      - ‚à´ x in a..b, (‚åäx‚åã + 1 / 2 - x) * deriv œÜ x := by
  have fl_a_eq_k : ‚åäa‚åã = k := Int.floor_eq_iff.mpr ‚ü®ha.1, by linarith [ha.2]‚ü©
  convert sum_eq_int_deriv_aux1 ha b_le_kpOne œÜDiff derivœÜCont using 2
  ¬∑ rw [fl_a_eq_k]
  ¬∑ congr
  ¬∑ apply intervalIntegral.integral_congr_ae
    have : ‚àÄ·µê (x : ‚Ñù) ‚àÇMeasureTheory.volume, x ‚â† b := by
      convert Countable.ae_not_mem (s := {b}) (by simp) (Œº := MeasureTheory.volume) using 1
    filter_upwards [this]
    intro x x_ne_b hx
    rw [uIoc_of_le ha.2.le, mem_Ioc] at hx
    congr
    exact Int.floor_eq_iff.mpr ‚ü®by linarith [ha.1], by have := Ne.lt_of_le x_ne_b hx.2; linarith‚ü©
/-%%
\begin{proof}\leanok
Partial integration.
\end{proof}
%%-/

-- Thanks to Arend Mellendijk

lemma interval_induction_aux_int (n : ‚Ñï) : ‚àÄ (P : ‚Ñù ‚Üí ‚Ñù ‚Üí Prop)
    (_ : ‚àÄ a b : ‚Ñù, ‚àÄ k : ‚Ñ§, k ‚â§ a ‚Üí a < b ‚Üí b ‚â§ k + 1 ‚Üí P a b)
    (_ : ‚àÄ (a : ‚Ñù) (k : ‚Ñ§) (c : ‚Ñù), a < k ‚Üí k < c ‚Üí P a k ‚Üí P k c ‚Üí P a c)
    (a b : ‚Ñù) (_ : a < b) (_ : n = ‚åäb‚åã - ‚åäa‚åã),
    P a b := by
  induction n using Nat.case_strong_induction_on with
  | hz =>
    intro P base _ a b hab hn
    apply base a b ‚åäa‚åã (Int.floor_le a) hab
    rw [(by simp only [CharP.cast_eq_zero] at hn; linarith : ‚åäa‚åã = ‚åäb‚åã)]
    exact (Int.lt_floor_add_one b).le
  | hi n ih =>
    intro P base step a b _ hn
    have Pa : P a (‚åäa‚åã + 1) :=
      base a (‚åäa‚åã + 1) ‚åäa‚åã (Int.floor_le a) (Int.lt_floor_add_one a) (le_of_eq rfl)
    by_cases b_le_flaP1 : b = ‚åäa‚åã + 1
    ¬∑ rwa [b_le_flaP1]
    have flaP1_lt_b : ‚åäa‚åã + 1 < b := by
      simp only [Nat.cast_succ] at hn
      have : (‚åäa‚åã : ‚Ñù) + 1 ‚â§ ‚åäb‚åã := by exact_mod_cast (by linarith)
      exact Ne.lt_of_le (id (Ne.symm b_le_flaP1)) (by linarith [Int.floor_le b] : ‚åäa‚åã + 1 ‚â§ b)
    have Pfla_b : P (‚åäa‚åã + 1) b := by
      apply ih n (le_of_eq rfl) P base step (‚åäa‚åã + 1) b flaP1_lt_b
      simp only [Int.floor_add_one, Int.floor_intCast, Nat.cast_succ] at hn ‚ä¢
      linarith
    refine step a (‚åäa‚åã + 1) b ?_ (by exact_mod_cast flaP1_lt_b) (by exact_mod_cast Pa)
      (by exact_mod_cast Pfla_b)
    have := Int.lt_floor_add_one a
    exact_mod_cast this

lemma interval_induction (P : ‚Ñù ‚Üí ‚Ñù ‚Üí Prop)
    (base : ‚àÄ a b : ‚Ñù, ‚àÄ k : ‚Ñ§, k ‚â§ a ‚Üí a < b ‚Üí b ‚â§ k + 1 ‚Üí P a b)
    (step : ‚àÄ (a : ‚Ñù) (k : ‚Ñ§) (b : ‚Ñù), a < k ‚Üí k < b ‚Üí P a k ‚Üí P k b ‚Üí P a b)
    (a b : ‚Ñù) (hab : a < b) : P a b := by
  set n := ‚åäb‚åã - ‚åäa‚åã with hn
  clear_value n
  have : 0 ‚â§ n := by simp only [hn, sub_nonneg, ge_iff_le, Int.floor_le_floor _ _ (hab.le)]
  lift n to ‚Ñï using this
  exact interval_induction_aux_int n P base step a b hab hn

/-%%
\begin{lemma}[sum_eq_int_deriv]\label{sum_eq_int_deriv}\lean{sum_eq_int_deriv}\leanok
  Let $a < b$, and let $\phi$ be continuously differentiable on $[a, b]$.
  Then
  \[
  \sum_{a < n \le b} \phi(n) = \int_a^b \phi(x) \, dx + \left(\lfloor b \rfloor + \frac{1}{2} - b\right) \phi(b) - \left(\lfloor a \rfloor + \frac{1}{2} - a\right) \phi(a) - \int_a^b \left(\lfloor x \rfloor + \frac{1}{2} - x\right) \phi'(x) \, dx.
  \]
\end{lemma}
%%-/
/-- ** Partial summation ** (TODO : Add to Mathlib). -/
theorem Finset.Ioc_diff_Ioc {Œ± : Type*} [LinearOrder Œ±] [LocallyFiniteOrder Œ±]
    {a b c: Œ±} [DecidableEq Œ±] (hb : b ‚àà Icc a c) : Ioc a b = Ioc a c \ Ioc b c := by
  ext x
  simp only [mem_Ioc, mem_sdiff, not_and, not_le]
  constructor
  ¬∑ refine fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®‚ü®h‚ÇÅ, le_trans h‚ÇÇ (mem_Icc.mp hb).2‚ü©, by contrapose! h‚ÇÇ; exact h‚ÇÇ.1‚ü©
  ¬∑ exact fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®h‚ÇÅ.1, by contrapose! h‚ÇÇ; exact ‚ü®h‚ÇÇ, h‚ÇÅ.2‚ü©‚ü©

-- In Ya√´l Dillies's API (https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finset.2Esum_add_adjacent_intervals/near/430127101)
lemma Finset.sum_Ioc_add_sum_Ioc {a b c : ‚Ñ§} (f : ‚Ñ§ ‚Üí ‚ÑÇ) (hb : b ‚àà Icc a c):
    (‚àë n in Finset.Ioc a b, f n) + (‚àë n in Finset.Ioc b c, f n) = ‚àë n in Finset.Ioc a c, f n := by
  convert Finset.sum_sdiff (s‚ÇÅ := Finset.Ioc b c) (s‚ÇÇ := Finset.Ioc a c) ?_
  ¬∑ exact Finset.Ioc_diff_Ioc hb
  ¬∑ exact Finset.Ioc_subset_Ioc (mem_Icc.mp hb).1 (by rfl)

lemma integrability_aux‚ÇÄ {a b : ‚Ñù} :
    ‚àÄ·µê (x : ‚Ñù) ‚àÇMeasureTheory.Measure.restrict MeasureTheory.volume [[a, b]],
      ‚Äñ(‚åäx‚åã : ‚ÑÇ)‚Äñ ‚â§ max ‚Äña‚Äñ ‚Äñb‚Äñ + 1 := by
  apply (MeasureTheory.ae_restrict_iff' measurableSet_Icc).mpr
  refine MeasureTheory.ae_of_all _ (fun x hx ‚Ü¶ ?_)
  simp only [inf_le_iff, le_sup_iff, mem_Icc] at hx
  simp only [norm_int, Real.norm_eq_abs]
  have : |x| ‚â§ max |a| |b| := by
    cases' hx.1 with x_ge_a x_ge_b <;> cases' hx.2 with x_le_a x_le_b
    ¬∑ rw [(by linarith : x = a)]; apply le_max_left
    ¬∑ apply abs_le_max_abs_abs x_ge_a x_le_b
    ¬∑ rw [max_comm]; apply abs_le_max_abs_abs x_ge_b x_le_a
    ¬∑ rw [(by linarith : x = b)]; apply le_max_right
  cases' abs_cases x with hx hx
  ¬∑ rw [_root_.abs_of_nonneg <| by exact_mod_cast Int.floor_nonneg.mpr hx.2]
    apply le_trans (Int.floor_le x) <| le_trans (hx.1 ‚ñ∏ this) (by simp)
  ¬∑ rw [_root_.abs_of_nonpos <| by exact_mod_cast Int.floor_nonpos hx.2.le]
    linarith [(Int.lt_floor_add_one x).le]

lemma integrability_aux‚ÇÅ {a b : ‚Ñù} :
    IntervalIntegrable (fun (x : ‚Ñù) ‚Ü¶ (‚åäx‚åã : ‚ÑÇ)) MeasureTheory.volume a b := by
  rw [intervalIntegrable_iff']
  apply MeasureTheory.Measure.integrableOn_of_bounded ?_ ?_ integrability_aux‚ÇÄ
  ¬∑ simp only [Real.volume_interval, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true]
  ¬∑ apply Measurable.aestronglyMeasurable
    apply Measurable.comp (by exact fun ‚¶Ét‚¶Ñ _ ‚Ü¶ trivial) Int.measurable_floor

lemma integrability_aux‚ÇÇ {a b : ‚Ñù} :
    IntervalIntegrable (fun (x : ‚Ñù) ‚Ü¶ (1 : ‚ÑÇ) / 2 - x) MeasureTheory.volume a b :=
  ContinuousOn.intervalIntegrable <| Continuous.continuousOn (by continuity)

lemma integrability_aux {a b : ‚Ñù} :
    IntervalIntegrable (fun (x : ‚Ñù) ‚Ü¶ (‚åäx‚åã : ‚ÑÇ) + 1 / 2 - x) MeasureTheory.volume a b := by
  convert integrability_aux‚ÇÅ.add integrability_aux‚ÇÇ using 2; ring

lemma uIcc_subsets {a b c : ‚Ñù} (hc : c ‚àà Icc a b) :
    [[a, c]] ‚äÜ [[a, b]] ‚àß [[c, b]] ‚äÜ [[a, b]] := by
  constructor <;> rw [uIcc_of_le ?_, uIcc_of_le ?_]
  any_goals apply Icc_subset_Icc
  all_goals linarith [hc.1, hc.2]

lemma sum_eq_int_deriv {œÜ : ‚Ñù ‚Üí ‚ÑÇ} {a b : ‚Ñù} (a_lt_b : a < b)
    (œÜDiff : ‚àÄ x ‚àà [[a, b]], HasDerivAt œÜ (deriv œÜ x) x)
    (derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]]) :
    ‚àë n in Finset.Ioc ‚åäa‚åã ‚åäb‚åã, œÜ n =
      (‚à´ x in a..b, œÜ x) + (‚åäb‚åã + 1 / 2 - b) * œÜ b - (‚åäa‚åã + 1 / 2 - a) * œÜ a
        - ‚à´ x in a..b, (‚åäx‚åã + 1 / 2 - x) * deriv œÜ x := by
  let P := fun a‚ÇÅ b‚ÇÅ ‚Ü¶ (‚àÄ x ‚àà [[a‚ÇÅ, b‚ÇÅ]], HasDerivAt œÜ (deriv œÜ x) x) ‚Üí
    (ContinuousOn (deriv œÜ) [[a‚ÇÅ, b‚ÇÅ]]) ‚Üí
    ‚àë n in Finset.Ioc ‚åäa‚ÇÅ‚åã ‚åäb‚ÇÅ‚åã, œÜ n =
    (‚à´ x in a‚ÇÅ..b‚ÇÅ, œÜ x) + (‚åäb‚ÇÅ‚åã + 1 / 2 - b‚ÇÅ) * œÜ b‚ÇÅ - (‚åäa‚ÇÅ‚åã + 1 / 2 - a‚ÇÅ) * œÜ a‚ÇÅ
      - ‚à´ x in a‚ÇÅ..b‚ÇÅ, (‚åäx‚åã + 1 / 2 - x) * deriv œÜ x
  apply interval_induction P ?base ?step a b a_lt_b œÜDiff derivœÜCont
  ¬∑ exact fun _ _ _ k‚ÇÅ_le_a‚ÇÅ a‚ÇÅ_lt_b‚ÇÅ b‚ÇÅ_le_k‚ÇÅ œÜDiff‚ÇÅ derivœÜCont‚ÇÅ ‚Ü¶
      sum_eq_int_deriv_aux ‚ü®k‚ÇÅ_le_a‚ÇÅ, a‚ÇÅ_lt_b‚ÇÅ‚ü© b‚ÇÅ_le_k‚ÇÅ œÜDiff‚ÇÅ derivœÜCont‚ÇÅ
  ¬∑ intro a‚ÇÅ k‚ÇÅ b‚ÇÅ a‚ÇÅ_lt_k‚ÇÅ k‚ÇÅ_lt_b‚ÇÅ ih‚ÇÅ ih‚ÇÇ œÜDiff‚ÇÅ derivœÜCont‚ÇÅ
    have subs := uIcc_subsets ‚ü®a‚ÇÅ_lt_k‚ÇÅ.le, k‚ÇÅ_lt_b‚ÇÅ.le‚ü©
    have s‚ÇÅ := ih‚ÇÅ (fun x hx ‚Ü¶ œÜDiff‚ÇÅ x <| subs.1 hx) <| derivœÜCont‚ÇÅ.mono subs.1
    have s‚ÇÇ := ih‚ÇÇ (fun x hx ‚Ü¶ œÜDiff‚ÇÅ x <| subs.2 hx) <| derivœÜCont‚ÇÅ.mono subs.2
    convert Mathlib.Tactic.LinearCombination.add_pf s‚ÇÅ s‚ÇÇ using 1
    ¬∑ rw [‚Üê Finset.sum_Ioc_add_sum_Ioc]
      simp only [Finset.mem_Icc, Int.floor_intCast, Int.le_floor]
      exact ‚ü®Int.cast_le.mp <| le_trans (Int.floor_le a‚ÇÅ) a‚ÇÅ_lt_k‚ÇÅ.le, k‚ÇÅ_lt_b‚ÇÅ.le‚ü©
    ¬∑ set I‚ÇÅ := ‚à´ (x : ‚Ñù) in a‚ÇÅ..b‚ÇÅ, œÜ x
      set I‚ÇÇ := ‚à´ (x : ‚Ñù) in a‚ÇÅ..k‚ÇÅ, œÜ x
      set I‚ÇÉ := ‚à´ (x : ‚Ñù) in k‚ÇÅ..b‚ÇÅ, œÜ x
      set J‚ÇÅ := ‚à´ (x : ‚Ñù) in a‚ÇÅ..b‚ÇÅ, (‚Üë‚åäx‚åã + 1 / 2 - ‚Üëx) * deriv œÜ x
      set J‚ÇÇ := ‚à´ (x : ‚Ñù) in a‚ÇÅ..k‚ÇÅ, (‚Üë‚åäx‚åã + 1 / 2 - ‚Üëx) * deriv œÜ x
      set J‚ÇÉ := ‚à´ (x : ‚Ñù) in k‚ÇÅ..b‚ÇÅ, (‚Üë‚åäx‚åã + 1 / 2 - ‚Üëx) * deriv œÜ x
      have hI : I‚ÇÇ + I‚ÇÉ = I‚ÇÅ := by
        apply intervalIntegral.integral_add_adjacent_intervals <;>
        apply ContinuousOn.intervalIntegrable
        ¬∑ exact HasDerivAt.continuousOn <| fun x hx ‚Ü¶ œÜDiff‚ÇÅ x <| subs.1 hx
        ¬∑ exact HasDerivAt.continuousOn <| fun x hx ‚Ü¶ œÜDiff‚ÇÅ x <| subs.2 hx
      have hJ : J‚ÇÇ + J‚ÇÉ = J‚ÇÅ := by
        apply intervalIntegral.integral_add_adjacent_intervals <;>
        apply IntervalIntegrable.mul_continuousOn
        any_goals apply integrability_aux
        ¬∑ exact derivœÜCont‚ÇÅ.mono subs.1
        ¬∑ exact derivœÜCont‚ÇÅ.mono subs.2
      rw [‚Üê hI, ‚Üê hJ]; ring
/-%%
\begin{proof}\uses{sum_eq_int_deriv_aux}\leanok
  Apply Lemma \ref{sum_eq_int_deriv_aux} in blocks of length $\le 1$.
\end{proof}
%%-/

lemma xpos_of_uIcc {a b : ‚Ñï} (ha : a ‚àà Ioo 0 b) {x : ‚Ñù} (x_in : x ‚àà [[(a : ‚Ñù), b]]) :
    0 < x := by
  rw [uIcc_of_le (by exact_mod_cast ha.2.le), mem_Icc] at x_in
  linarith [(by exact_mod_cast ha.1 : (0 : ‚Ñù) < a)]

lemma neg_s_ne_neg_one {s : ‚ÑÇ} (s_ne_one : s ‚â† 1) : -s ‚â† -1 := fun hs ‚Ü¶ s_ne_one <| neg_inj.mp hs

lemma ZetaSum_aux1‚ÇÅ {a b : ‚Ñï} {s : ‚ÑÇ} (s_ne_one : s ‚â† 1) (ha : a ‚àà Ioo 0 b) :
    (‚à´ (x : ‚Ñù) in a..b, 1 / (x : ‚ÑÇ) ^ s) =
    (b ^ (1 - s) - a ^ (1 - s)) / (1 - s) := by
  convert integral_cpow (a := a) (b := b) (r := -s) ?_ using 1
  ¬∑ refine intervalIntegral.integral_congr fun x hx ‚Ü¶ one_div_cpow_eq ?_
    exact (xpos_of_uIcc ha hx).ne'
  ¬∑ norm_cast; rw [(by ring : -s + 1 = 1 - s)]
  ¬∑ right; refine ‚ü®neg_s_ne_neg_one s_ne_one, ?_‚ü©
    exact fun hx ‚Ü¶ (lt_self_iff_false 0).mp <| xpos_of_uIcc ha hx

lemma ZetaSum_aux1œÜDiff {s : ‚ÑÇ} {x : ‚Ñù} (xpos : 0 < x) :
    HasDerivAt (fun (t : ‚Ñù) ‚Ü¶ 1 / (t : ‚ÑÇ) ^ s) (deriv (fun (t : ‚Ñù) ‚Ü¶ 1 / (t : ‚ÑÇ) ^ s) x) x := by
  apply hasDerivAt_deriv_iff.mpr <| DifferentiableAt.div (differentiableAt_const _) ?_ ?_
  ¬∑ exact Real.differentiableAt_cpow_const_of_ne s xpos
  ¬∑ simp [cpow_eq_zero_iff, xpos.ne']

lemma ZetaSum_aux1œÜderiv {s : ‚ÑÇ} (s_ne_zero : s ‚â† 0) {x : ‚Ñù} (xpos : 0 < x) :
    deriv (fun (t : ‚Ñù) ‚Ü¶ 1 / (t : ‚ÑÇ) ^ s) x = (fun (x : ‚Ñù) ‚Ü¶ -s * (x : ‚ÑÇ) ^ (-(s + 1))) x := by
  let r := -s - 1
  have r_add1_ne_zero : r + 1 ‚â† 0 := fun hr ‚Ü¶ by simp [neg_ne_zero.mpr s_ne_zero, r] at hr
  have r_ne_neg1 : r ‚â† -1 := fun hr ‚Ü¶ (hr ‚ñ∏ r_add1_ne_zero) <| by norm_num
  have hasDeriv := hasDerivAt_ofReal_cpow xpos.ne' r_ne_neg1
  have := hasDeriv.deriv ‚ñ∏ deriv_const_mul (-s) (hasDeriv).differentiableAt
  convert this using 2
  ¬∑ ext y
    by_cases y_zero : (y : ‚ÑÇ) = 0
    ¬∑ simp only [y_zero, ofReal_zero, ne_eq, s_ne_zero, not_false_eq_true, zero_cpow, div_zero,
      r_add1_ne_zero, zero_div, mul_zero]
    ¬∑ have : (y : ‚ÑÇ) ^ s ‚â† 0 := fun hy ‚Ü¶ y_zero ((cpow_eq_zero_iff _ _).mp hy).1
      field_simp [r, mul_assoc, ‚Üê Complex.cpow_add]
  ¬∑ ring_nf

lemma ZetaSum_aux1derivœÜCont {s : ‚ÑÇ} (s_ne_zero : s ‚â† 0) {a b : ‚Ñï} (ha : a ‚àà Ioo 0 b) :
    ContinuousOn (deriv (fun (t : ‚Ñù) ‚Ü¶ 1 / (t : ‚ÑÇ) ^ s)) [[a, b]] := by
  have : EqOn _ (fun (t : ‚Ñù) ‚Ü¶ -s * (t : ‚ÑÇ) ^ (-(s + 1))) [[a, b]] :=
    fun x hx ‚Ü¶ ZetaSum_aux1œÜderiv s_ne_zero <| xpos_of_uIcc ha hx
  refine ContinuousOn.congr ?_ this
  refine (ContinuousOn.cpow_const continuous_ofReal.continuousOn ?_).const_smul (c := -s)
  exact fun x hx ‚Ü¶ ofReal_mem_slitPlane.mpr <| xpos_of_uIcc ha hx

/-%%
\begin{lemma}[ZetaSum_aux1]\label{ZetaSum_aux1}\lean{ZetaSum_aux1}\leanok
  Let $0 < a < b$ be natural numbers and $s\in \C$ with $s \ne 1$ and $s \ne 0$.
  Then
  \[
  \sum_{a < n \le b} \frac{1}{n^s} =  \frac{b^{1-s} - a^{1-s}}{1-s} + \frac{b^{-s}-a^{-s}}{2} + s \int_a^b \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx.
  \]
\end{lemma}
%%-/
lemma ZetaSum_aux1 {a b : ‚Ñï} {s : ‚ÑÇ} (s_ne_one : s ‚â† 1) (s_ne_zero : s ‚â† 0) (ha : a ‚àà Ioo 0 b) :
    ‚àë n in Finset.Ioc (a : ‚Ñ§) b, 1 / (n : ‚ÑÇ) ^ s =
    (b ^ (1 - s) - a ^ (1 - s)) / (1 - s) + 1 / 2 * (1 / b ^ (s)) - 1 / 2 * (1 / a ^ s)
      + s * ‚à´ x in a..b, (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(s + 1)) := by
  let œÜ := fun (x : ‚Ñù) ‚Ü¶ 1 / (x : ‚ÑÇ) ^ s
  let œÜ' := fun (x : ‚Ñù) ‚Ü¶ -s * (x : ‚ÑÇ) ^ (-(s + 1))
  have xpos : ‚àÄ x ‚àà [[(a : ‚Ñù), b]], 0 < x := fun x hx ‚Ü¶ xpos_of_uIcc ha hx
  have œÜDiff : ‚àÄ x ‚àà [[(a : ‚Ñù), b]], HasDerivAt œÜ (deriv œÜ x) x := fun x hx ‚Ü¶ ZetaSum_aux1œÜDiff (xpos x hx)
  have œÜderiv : ‚àÄ x ‚àà [[(a : ‚Ñù), b]], deriv œÜ x = œÜ' x := by
    exact fun x hx ‚Ü¶ ZetaSum_aux1œÜderiv s_ne_zero (xpos x hx)
  have derivœÜCont : ContinuousOn (deriv œÜ) [[a, b]] := ZetaSum_aux1derivœÜCont s_ne_zero ha
  convert sum_eq_int_deriv (by exact_mod_cast ha.2) œÜDiff derivœÜCont using 1
  ¬∑ congr <;> simp only [Int.floor_natCast]
  ¬∑ rw [Int.floor_natCast, Int.floor_natCast, ‚Üê intervalIntegral.integral_const_mul]
    simp_rw [mul_div, ‚Üê mul_div, ZetaSum_aux1‚ÇÅ s_ne_one ha]
    conv => rhs; rw [sub_eq_add_neg]
    congr; any_goals norm_cast; simp only [one_div, add_sub_cancel_left]
    rw [‚Üê intervalIntegral.integral_neg, intervalIntegral.integral_congr]
    intro x hx; simp_rw [œÜderiv x hx, œÜ']; ring_nf
/-%%
\begin{proof}\uses{sum_eq_int_deriv}\leanok
  Apply Lemma \ref{sum_eq_int_deriv} to the function $x \mapsto x^{-s}$.
\end{proof}
%%-/

lemma ZetaSum_aux1_1' {a b x : ‚Ñù} (apos : 0 < a) (hx : x ‚àà Icc a b)
    : 0 < x := lt_of_lt_of_le apos hx.1

lemma ZetaSum_aux1_1 {a b x : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) (hx : x ‚àà [[a,b]])
    : 0 < x :=  lt_of_lt_of_le apos (uIcc_of_le a_lt_b.le ‚ñ∏ hx).1

lemma ZetaSum_aux1_2 {a b : ‚Ñù} {c : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b)
    (h : c ‚â† 0 ‚àß 0 ‚àâ [[a, b]]) :
    ‚à´ (x : ‚Ñù) in a..b, 1 / x ^ (c+1) = (a ^ (-c) - b ^ (-c)) / c := by
  rw [(by ring : (a ^ (-c) - b ^ (-c)) / c = (b ^ (-c) - a ^ (-c)) / (-c))]
  have := integral_rpow (a := a) (b := b) (r := -c-1) (Or.inr ‚ü®by simp [h.1], h.2‚ü©)
  simp only [sub_add_cancel] at this
  rw [‚Üê this]
  apply intervalIntegral.integral_congr
  intro x hx
  have : 0 ‚â§ x := (ZetaSum_aux1_1 apos a_lt_b hx).le
  simp [div_rpow_eq_rpow_neg _ _ _ this, sub_eq_add_neg, add_comm]

lemma ZetaSum_aux1_3a (x : ‚Ñù) : -(1/2) < ‚åä x ‚åã + 1/2 - x := by
  norm_num [‚Üê add_assoc]; linarith [sub_pos_of_lt (Int.lt_floor_add_one x)]

lemma ZetaSum_aux1_3b (x : ‚Ñù) : ‚åäx‚åã + 1/2 - x ‚â§ 1/2 := by
  ring_nf; exact add_le_of_nonpos_right <| sub_nonpos.mpr (Int.floor_le x)

lemma ZetaSum_aux1_3 (x : ‚Ñù) : |(‚åäx‚åã + 1/2 - x)| ‚â§ 1/2 :=
  abs_le.mpr ‚ü®le_of_lt (ZetaSum_aux1_3a x), ZetaSum_aux1_3b x‚ü©

lemma ZetaSum_aux1_4' (x : ‚Ñù) (hx : 0 < x) (s : ‚ÑÇ) :
      ‚Äñ(‚åäx‚åã + 1 / 2 - (x : ‚Ñù)) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ =
      |‚åäx‚åã + 1 / 2 - x| / x ^ ((s + 1).re) := by
  simp [map_div‚ÇÄ, abs_ofReal, Complex.abs_cpow_eq_rpow_re_of_pos hx, ‚Üê abs_ofReal]

lemma ZetaSum_aux1_4 {a b : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) {s : ‚ÑÇ} :
  ‚à´ (x : ‚Ñù) in a..b, ‚Äñ(‚Üë‚åäx‚åã + (1 : ‚Ñù) / 2 - ‚Üëx) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ =
    ‚à´ (x : ‚Ñù) in a..b, |‚åäx‚åã + 1 / 2 - x| / x ^ (s + 1).re := by
  apply intervalIntegral.integral_congr
  exact fun x hx ‚Ü¶ ZetaSum_aux1_4' x (ZetaSum_aux1_1 apos a_lt_b hx) s

lemma ZetaSum_aux1_5a {a b : ‚Ñù} (apos : 0 < a) {s : ‚ÑÇ} (x : ‚Ñù)
  (h : x ‚àà Icc a b) : |‚Üë‚åäx‚åã + 1 / 2 - x| / x ^ (s.re + 1) ‚â§ 1 / x ^ (s.re + 1) := by
  apply div_le_div_of_nonneg_right _ _
  ¬∑ exact le_trans (ZetaSum_aux1_3 x) (by norm_num)
  ¬∑ apply Real.rpow_nonneg <| le_of_lt (ZetaSum_aux1_1' apos h)

lemma ZetaSum_aux1_5b {a b : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) {s : ‚ÑÇ} (œÉpos : 0 < s.re) :
  IntervalIntegrable (fun u ‚Ü¶ 1 / u ^ (s.re + 1)) MeasureTheory.volume a b := by
  apply ContinuousOn.intervalIntegrable_of_Icc (le_of_lt a_lt_b) _
  apply ContinuousOn.div continuousOn_const
  ¬∑ refine ContinuousOn.rpow_const continuousOn_id ?_
    exact fun x hx ‚Ü¶ Or.inl (ne_of_gt <| ZetaSum_aux1_1' apos hx)
  ¬∑ exact fun x hx h ‚Ü¶ by rw [Real.rpow_eq_zero] at h <;> linarith [ZetaSum_aux1_1' apos hx]

lemma ZetaSum_aux1_5c {a b : ‚Ñù} {s : ‚ÑÇ} :
    let g : ‚Ñù ‚Üí ‚Ñù := fun u ‚Ü¶ |‚Üë‚åäu‚åã + 1 / 2 - u| / u ^ (s.re + 1);
    MeasureTheory.AEStronglyMeasurable g
      (MeasureTheory.Measure.restrict MeasureTheory.volume (Œô a b)) := by
  intro
  refine (Measurable.div ?_ <| measurable_id.pow_const _).aestronglyMeasurable
  refine (_root_.continuous_abs).measurable.comp ?_
  refine Measurable.sub (Measurable.add ?_ measurable_const) measurable_id
  exact Measurable.comp (by exact fun _ _ ‚Ü¶ trivial) Int.measurable_floor

lemma ZetaSum_aux1_5d {a b : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) {s : ‚ÑÇ} (œÉpos : 0 < s.re) :
  IntervalIntegrable (fun u ‚Ü¶ |‚Üë‚åäu‚åã + 1 / 2 - u| / u ^ (s.re + 1)) MeasureTheory.volume a b := by
  set g : ‚Ñù ‚Üí ‚Ñù := (fun u ‚Ü¶ |‚Üë‚åäu‚åã + 1 / 2 - u| / u ^ (s.re + 1))
  apply IntervalIntegrable.mono_fun (ZetaSum_aux1_5b apos a_lt_b œÉpos) ZetaSum_aux1_5c ?_
  filter_upwards with x
  simp only [g, Real.norm_eq_abs, one_div, norm_inv, abs_div, _root_.abs_abs]
  conv => rw [div_eq_mul_inv, ‚Üê one_div]; rhs; rw [‚Üê one_mul |x ^ (s.re + 1)|‚Åª¬π]
  refine mul_le_mul ?_ (le_refl _) (by simp) <| by norm_num
  exact le_trans (ZetaSum_aux1_3 x) <| by norm_num

lemma ZetaSum_aux1_5 {a b : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) {s : ‚ÑÇ} (œÉpos : 0 < s.re) :
  ‚à´ (x : ‚Ñù) in a..b, |‚åäx‚åã + 1 / 2 - x| / x ^ (s.re + 1) ‚â§ ‚à´ (x : ‚Ñù) in a..b, 1 / x ^ (s.re + 1) := by
  apply intervalIntegral.integral_mono_on (le_of_lt a_lt_b) ?_ ?_
  ¬∑ exact ZetaSum_aux1_5a apos
  ¬∑ exact ZetaSum_aux1_5d apos a_lt_b œÉpos
  ¬∑ exact ZetaSum_aux1_5b apos a_lt_b œÉpos

/-%%
\begin{lemma}[ZetaSum_aux1a]\label{ZetaSum_aux1a}\lean{ZetaSum_aux1a}\leanok
For any $0 < a < b$ and  $s \in \C$ with $\sigma=\Re(s)>0$,
$$
\left|\int_a^b \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx\right|
\le \frac{a^{-\sigma}-b^{-\sigma}}{\sigma}.
$$
\end{lemma}
%%-/
lemma ZetaSum_aux1a {a b : ‚Ñù} (apos : 0 < a) (a_lt_b : a < b) {s : ‚ÑÇ} (œÉpos : 0 < s.re) :
    ‚Äñ‚à´ x in a..b, (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ ‚â§
      (a ^ (-s.re) - b ^ (-s.re)) / s.re := by
  calc
    _ ‚â§ ‚à´ x in a..b, ‚Äñ(‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ := ?_
    _ = ‚à´ x in a..b, |(‚åäx‚åã + 1 / 2 - x)| / x ^ (s+1).re := ZetaSum_aux1_4 apos a_lt_b
    _ ‚â§ ‚à´ x in a..b, 1 / x ^ (s.re + 1) := ZetaSum_aux1_5 apos a_lt_b œÉpos
    _ = (a ^ (-s.re) - b ^ (-s.re)) / s.re := ?_
  ¬∑ exact intervalIntegral.norm_integral_le_integral_norm (Œº := MeasureTheory.volume)
      (a := a) (b := b) (f := fun x ‚Ü¶ (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)) (le_of_lt a_lt_b)
  ¬∑ refine ZetaSum_aux1_2 (c := s.re) apos a_lt_b ‚ü®ne_of_gt œÉpos, ?_‚ü©
    exact fun h ‚Ü¶ (lt_self_iff_false 0).mp <| ZetaSum_aux1_1 apos a_lt_b h
/-%%
\begin{proof}\leanok
Apply the triangle inequality
$$
\left|\int_a^b \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx\right|
\le \int_a^b \frac{1}{x^{\sigma+1}} \, dx,
$$
and evaluate the integral.
\end{proof}
%%-/

-- no longer used
lemma tsum_eq_partial_add_tail {N : ‚Ñï} (f : ‚Ñï ‚Üí ‚ÑÇ) (hf : Summable f) :
    ‚àë' (n : ‚Ñï), f n = (‚àë n in Finset.Ico 0 N, f n) + ‚àë' (n : ‚Ñï), f (n + N) := by
  rw [‚Üê sum_add_tsum_nat_add (f := f) (h := hf) (k := N), Finset.range_eq_Ico]

lemma finsetSum_tendsto_tsum {N : ‚Ñï} {f : ‚Ñï ‚Üí ‚ÑÇ} (hf : Summable f) :
    Tendsto (fun (k : ‚Ñï) ‚Ü¶ ‚àë n in Finset.Ioc N k, f n) atTop (ùìù (‚àë' (n : ‚Ñï), f (n + N))) := by
  have := (@Summable.hasSum_iff_tendsto_nat (f := fun m ‚Ü¶ f (m + N))
     (m := ‚àë' (n : ‚Ñï), f (n + N)) _ _ _ ?_).mp ?_
  ¬∑ convert this using 2
    rename ‚Ñï => M
    simp_rw [Finset.range_eq_Ico]
    sorry
  swap; apply (Summable.hasSum_iff ?_).mpr; rfl
  all_goals
  sorry

lemma tendsto_coe_atTop : Tendsto (fun (n : ‚Ñï) ‚Ü¶ (n : ‚Ñù)) atTop atTop := by
  rw [Filter.tendsto_atTop_atTop]
  intro b
  use ‚åäb‚åã.toNat + 1
  intro a ha
  by_cases a_zero : a = 0
  ¬∑ simp [a_zero] at ha
  ¬∑ by_cases h : ‚åäb‚åã.toNat < a
    ¬∑ exact (Int.floor_lt.mp <| (Int.toNat_lt' a_zero).mp h).le
    ¬∑ simp only [not_lt] at h
      absurd le_trans ha h
      simp

-- related to `ArithmeticFunction.LSeriesSummable_zeta_iff.mpr s_re_gt`
lemma Summable_rpow {s : ‚ÑÇ} (s_re_gt : 1 < s.re) : Summable (fun (n : ‚Ñï) ‚Ü¶ 1 / (n : ‚ÑÇ) ^ s) := by
  apply Summable.of_norm
  have : s.re ‚â† 0 := by linarith
  simp only [one_div, norm_inv]
  simp_rw [norm_natCast_cpow_of_re_ne_zero _ this]
  exact (Real.summable_nat_rpow_inv (p := s.re)).mpr s_re_gt

lemma Finset_coe_Nat_Int (f : ‚Ñ§ ‚Üí ‚ÑÇ) (m n : ‚Ñï) :
    (‚àë x in Finset.Ioc m n, f x) = ‚àë x in Finset.Ioc (m : ‚Ñ§) n, f x := by
/-
instead use `Finset.sum_map` and a version of `Nat.image_cast_int_Ioc` stated using `Finset.map`
-/
  apply Finset.sum_nbij (i := (fun (x : ‚Ñï) ‚Ü¶ (x : ‚Ñ§)))
  ¬∑ intro x hx
    simp only [Finset.mem_Ioc, Nat.cast_lt, Nat.cast_le] at hx ‚ä¢
    exact hx
  ¬∑ intro x‚ÇÅ _ x‚ÇÇ _ h
    simp only [Nat.cast_inj] at h
    exact h
  ¬∑ intro x hx
    simp only [Finset.coe_Ioc, mem_image, mem_Ioc] at hx ‚ä¢
    have : 0 ‚â§ x := by linarith
    lift x to ‚Ñï using this
    exact ‚ü®x, by exact_mod_cast hx, rfl‚ü©
  ¬∑ exact fun _ _ ‚Ü¶ rfl

lemma Complex.cpow_tendsto {s : ‚ÑÇ} (s_re_gt : 1 < s.re) :
    Tendsto (fun (x : ‚Ñï) ‚Ü¶ (x : ‚ÑÇ) ^ (1 - s)) atTop (ùìù 0) := by
  have one_sub_s_re_ne : (1 - s).re ‚â† 0 := by simp only [sub_re, one_re]; linarith
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simp_rw [Complex.norm_natCast_cpow_of_re_ne_zero _ (one_sub_s_re_ne)]
  rw [(by simp only [sub_re, one_re, neg_sub] : (1 - s).re = - (s - 1).re)]
  apply (tendsto_rpow_neg_atTop _).comp tendsto_nat_cast_atTop_atTop; simp [s_re_gt]

lemma Complex.cpow_inv_tendsto {s : ‚ÑÇ} (hs : 0 < s.re) :
    Tendsto (fun (x : ‚Ñï) ‚Ü¶ ((x : ‚ÑÇ) ^ s)‚Åª¬π) atTop (ùìù 0) := by
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simp_rw [norm_inv, Complex.norm_natCast_cpow_of_re_ne_zero _ <| ne_of_gt hs]
  apply Filter.Tendsto.inv_tendsto_atTop
  exact (tendsto_rpow_atTop hs).comp tendsto_nat_cast_atTop_atTop

lemma ZetaSum_aux2a : ‚àÉ C, ‚àÄ (x : ‚Ñù), |‚åäx‚åã + 1 / 2 - x| ‚â§ C := by
  use 1 / 2
  intro x
  rcases abs_cases (‚åäx‚åã + 1 / 2 - x) with ‚ü®h‚ÇÅ, _‚ü© | ‚ü®h‚ÇÅ, _‚ü© <;> rw [h‚ÇÅ]
  ¬∑ linarith [Int.floor_le x]
  ¬∑ linarith [Int.lt_floor_add_one x]

/-%%
\begin{lemma}[ZetaSum_aux2]\label{ZetaSum_aux2}\lean{ZetaSum_aux2}\leanok
  Let $N$ be a natural number and $s\in \C$, $\Re(s)>1$.
  Then
  \[
  \sum_{N < n} \frac{1}{n^s} =  \frac{- N^{1-s}}{1-s} + \frac{-N^{-s}}{2} + s \int_N^\infty \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx.
  \]
\end{lemma}
%%-/
lemma ZetaSum_aux2 {N : ‚Ñï} (N_pos : 0 < N) {s : ‚ÑÇ} (s_re_gt : 1 < s.re) :
    ‚àë' (n : ‚Ñï), 1 / (n + N : ‚ÑÇ) ^ s =
    (- N ^ (1 - s)) / (1 - s) - N ^ (-s) / 2
      + s * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(s + 1)) := by
  have s_ne_zero : s ‚â† 0 := fun hs ‚Ü¶ by linarith [zero_re ‚ñ∏ hs ‚ñ∏ s_re_gt]
  have s_ne_one : s ‚â† 1 := fun hs ‚Ü¶ (lt_self_iff_false _).mp <| one_re ‚ñ∏ hs ‚ñ∏ s_re_gt
  apply tendsto_nhds_unique (X := ‚ÑÇ) (Y := ‚Ñï) (l := atTop)
    (f := fun k ‚Ü¶ ((k : ‚ÑÇ) ^ (1 - s) - (N : ‚ÑÇ) ^ (1 - s)) / (1 - s) + 1 / 2 * (1 / ‚Üëk ^ s) - 1 / 2 * (1 / ‚ÜëN ^ s)
      + s * ‚à´ (x : ‚Ñù) in (N : ‚Ñù)..k, (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(s + 1)))
    (b := (- N ^ (1 - s)) / (1 - s) - N ^ (-s) / 2
      + s * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(s + 1)))
  ¬∑ apply Filter.Tendsto.congr' (f‚ÇÅ := fun (k : ‚Ñï) ‚Ü¶ ‚àë n in Finset.Ioc N k, 1 / (n : ‚ÑÇ) ^ s) (l‚ÇÅ := atTop)
    ¬∑ apply Filter.eventually_atTop.mpr
      use N + 1
      intro k hk
      convert ZetaSum_aux1 (a := N) (b := k) s_ne_one s_ne_zero ‚ü®N_pos, hk‚ü© using 1
      convert Finset_coe_Nat_Int (fun n ‚Ü¶ 1 / (n : ‚ÑÇ) ^ s) N k
    ¬∑ convert finsetSum_tendsto_tsum (f := fun n ‚Ü¶ 1 / (n : ‚ÑÇ) ^ s) (Summable_rpow s_re_gt); simp
  ¬∑ apply (Tendsto.sub ?_ ?_).add (Tendsto.const_mul _ ?_)
    ¬∑ rw [(by ring : -‚ÜëN ^ (1 - s) / (1 - s) = (0 - ‚ÜëN ^ (1 - s)) / (1 - s) + 0)]
      apply cpow_tendsto s_re_gt |>.sub_const _ |>.div_const _ |>.add
      simp_rw [mul_comm_div, one_mul, one_div, (by congr; ring : ùìù (0 : ‚ÑÇ) = ùìù ((0 : ‚ÑÇ) / 2))]
      apply Tendsto.div_const <| cpow_inv_tendsto (by positivity)
    ¬∑ simp_rw [mul_comm_div, one_mul, one_div, cpow_neg]; exact tendsto_const_nhds
    ¬∑ refine MeasureTheory.intervalIntegral_tendsto_integral_Ioi (a := N)
        (b := (fun (n : ‚Ñï) ‚Ü¶ (n : ‚Ñù))) ?_ tendsto_coe_atTop
      apply MeasureTheory.Integrable.bdd_mul ?_ ?_
      ¬∑ convert ZetaSum_aux2a; simp [‚Üê Complex.abs_ofReal]
      ¬∑ apply integrableOn_Ioi_cpow_iff (by positivity) |>.mpr (by simp [s_re_gt]; positivity)
      ¬∑ sorry
/-%%
\begin{proof}\uses{ZetaSum_aux1}
  Apply Lemma \ref{ZetaSum_aux1} with $a=N$ and $b\to \infty$.
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaBnd_aux1]\label{ZetaBnd_aux1}\lean{ZetaBnd_aux1}\leanok
For any $N\ge1$ and $s\in \C$, $\sigma=\Re(s)\in(0,2]$,
$$
\left| s\int_N^\infty \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx \right|
\ll |t| \frac{N^{-\sigma}}{\sigma},
$$
as $|t|\to\infty$.
\end{lemma}
%%-/

def ct_aux1 := 31381059610 -- 3 ^ 22 + 1
def C_aux1 := 100

lemma ZetaBnd_aux1 (N : ‚Ñï) (Npos : 1 ‚â§ N) {œÉ : ‚Ñù} (hœÉ : œÉ ‚àà Ioc 0 2) :
    ‚àÄ (t : ‚Ñù) (ht : ct_aux1 < |t|),
    ‚Äñ(œÉ + t * I) * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ ((œÉ + t * I) + 1)‚Äñ
    ‚â§ C_aux1 * |t| * N ^ (-œÉ) / œÉ := by
  have := @ZetaSum_aux1a (a := N)
  sorry
/-%%
\begin{proof}\uses{ZetaSum_aux1a}
Apply Lemma \ref{ZetaSum_aux1a} with $a=N$ and $b\to \infty$, and estimate $|s|\ll |t|$.
\end{proof}
%%-/


/-%%
\begin{lemma}[HolomorphicOn_Zeta0]\label{HolomorphicOn_Zeta0}\lean{HolomorphicOn_Zeta0}\leanok
For any $N\ge1$, the function $\zeta_0(N,s)$ is holomorphic on $\{s\in \C\mid \Re(s)>0\}$.
\end{lemma}
%%-/
lemma HolomorphicOn_riemannZeta0 {N : ‚Ñï} (N_pos : 0 < N) :
    HolomorphicOn (Œ∂‚ÇÄ N) {s : ‚ÑÇ | s ‚â† 1 ‚àß 0 < s.re} := by
  sorry
/-%%
\begin{proof}\uses{ZetaSum_aux1}
  The function $\zeta_0(N,s)$ is a finite sum of entire functions, plus an integral
  that's absolutely convergent on $\{s\in \C\mid \Re(s)>0 ‚àß s \ne 1\}$ by Lemma \ref{ZetaSum_aux1}.
%%-/

-- MOVE TO MATHLIB near `differentiableAt_riemannZeta`
lemma HolomophicOn_riemannZeta :
    HolomorphicOn Œ∂ {s : ‚ÑÇ | s ‚â† 1} := by
  intro z hz
  simp only [mem_setOf_eq] at hz
  exact (differentiableAt_riemannZeta hz).differentiableWithinAt


/-%%
\begin{lemma}[isPathConnected_aux]\label{isPathConnected_aux}\lean{isPathConnected_aux}\leanok
The set $\{s\in \C\mid \Re(s)>0 ‚àß s \ne 1\}$ is path-connected.
\end{lemma}
%%-/
lemma isPathConnected_aux : IsPathConnected {z : ‚ÑÇ | z ‚â† 1 ‚àß 0 < z.re} := by
  use (2 : ‚ÑÇ)
  constructor; simp
  intro y hy; simp only [ne_eq, mem_setOf_eq] at hy
  by_cases h : y.re ‚â§ 1
  ¬∑ apply JoinedIn.trans (y := I)
    ¬∑ sorry
    ¬∑ sorry
  ¬∑ let f : ‚Ñù ‚Üí ‚ÑÇ := fun t ‚Ü¶ y * t + 2 * (1 - t)
    have cont : Continuous f := by continuity
    apply JoinedIn.ofLine cont.continuousOn (by simp [f]) (by simp [f])
    simp [f, unitInterval]
    intro x hx; simp only [mem_Icc] at hx
    simp only [mem_setOf_eq]
    constructor
    ¬∑ suffices ¬¨ (2 - y) * x = 1 by
        convert this using 1
        ring_nf
        sorry
      simp [Complex.ext_iff]
      contrapose!
      intro hxy
      rcases hxy with (hx1 | hy1)
      ¬∑ have hyre: 2 - y.re < 1 := by linarith
        by_cases hx2 : x = 0
        ¬∑ simp only [hx2]; linarith
        ¬∑ have := mul_lt_mul (a := 2 - y.re) (b := x) (c := 1) (d := 1) hyre hx.2
            (lt_of_le_of_ne hx.1 <| ((Ne.def _ _).symm ‚ñ∏ hx2).symm) (by norm_num)
          linarith
      ¬∑ simp [hy1]
    ¬∑ sorry
/-%%
\begin{proof}
  Construct explicit paths from $2$ to any point, either a line segment or two joined ones.
%%-/


/-%%
\begin{lemma}[Zeta0EqZeta]\label{Zeta0EqZeta}\lean{Zeta0EqZeta}\leanok
For $\Re(s)>0$, $s\ne1$, and for any $N$,
$$
\zeta_0(N,s) = \zeta(s).
$$
\end{lemma}
%%-/
lemma Zeta0EqZeta {N : ‚Ñï} (N_pos : 0 < N) {s : ‚ÑÇ} (reS_pos : 0 < s.re) (s_ne_one : s ‚â† 1) :
    Œ∂‚ÇÄ N s = riemannZeta s := by
  let f := riemannZeta
  let g := Œ∂‚ÇÄ N
  let U := {z : ‚ÑÇ | z ‚â† 1 ‚àß 0 < z.re}
  have U_open : IsOpen U := by
    refine IsOpen.inter isOpen_ne ?_
    exact isOpen_lt (g := fun (z : ‚ÑÇ) ‚Ü¶ z.re) (by continuity) (by continuity)
  have f_an : AnalyticOn ‚ÑÇ f U := by
    apply (HolomophicOn_riemannZeta.analyticOn isOpen_ne).mono
    simp only [ne_eq, setOf_subset_setOf, and_imp, U]
    exact fun a ha _ ‚Ü¶ ha
  have g_an : AnalyticOn ‚ÑÇ g U := (HolomorphicOn_riemannZeta0 N_pos).analyticOn U_open
  have preconU : IsPreconnected U := by
    apply IsConnected.isPreconnected
    apply (IsOpen.isConnected_iff_isPathConnected U_open).mp isPathConnected_aux
  have h2 : (2 : ‚ÑÇ) ‚àà U := by simp [U]
  have s_mem : s ‚àà U := by simp [U, reS_pos, s_ne_one]
  convert (AnalyticOn.eqOn_of_preconnected_of_eventuallyEq f_an g_an preconU h2 ?_ s_mem).symm
  have u_mem : {z : ‚ÑÇ | 1 < z.re} ‚àà ùìù (2 : ‚ÑÇ) := by
    apply mem_nhds_iff.mpr
    use {z : ‚ÑÇ | 1 < z.re}
    simp only [setOf_subset_setOf, imp_self, forall_const, mem_setOf_eq, re_ofNat,
      Nat.one_lt_ofNat, and_true, true_and]
    exact isOpen_lt (by continuity) (by continuity)
  filter_upwards [u_mem]
  intro z hz
  simp only [f,g, zeta_eq_tsum_one_div_nat_cpow hz, riemannZeta0_apply]
  nth_rewrite 2 [neg_div]
  rw [‚Üê sub_eq_add_neg, ‚Üê ZetaSum_aux2 N_pos hz, ‚Üê sum_add_tsum_nat_add N (Summable_rpow hz)]
  congr
  simp
/-%%
\begin{proof}\leanok
\uses{ZetaSum_aux2, RiemannZeta0, HolomorphicOn_Zeta0, isPathConnected_aux}
Use Lemma \ref{ZetaSum_aux2} and the Definition \ref{RiemannZeta0}.
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaBnd_aux2]\label{ZetaBnd_aux2}\lean{ZetaBnd_aux2}\leanok
Given $n ‚â§ t$ and $\sigma$ with $1-A/\log t \le \sigma$, we have
that
$$
|n^{-s}| \le n^{-1} e^A.
$$
\end{lemma}
%%-/
lemma ZetaBnd_aux2 {n : ‚Ñï} {t A œÉ : ‚Ñù} (Apos : 0 < A) (œÉpos : 0 < œÉ) (n_le_t : n ‚â§ |t|)
    (œÉ_ge : (1 : ‚Ñù) - A / |t|.log ‚â§ œÉ) :
    ‚Äñ(n : ‚ÑÇ) ^ (-(œÉ + t * I))‚Äñ ‚â§ (n : ‚Ñù)‚Åª¬π * Real.exp A := by
  set s := œÉ + t * I
  by_cases n0 : n = 0
  ¬∑ simp_rw [n0, CharP.cast_eq_zero, inv_zero, zero_mul]
    rw [Complex.zero_cpow ?_]; simp
    exact fun h ‚Ü¶ (NeZero.of_pos œÉpos).ne <| zero_eq_neg.mp <| zero_re ‚ñ∏ h ‚ñ∏ (by simp [s])
  have n_gt_0 : 0 < n := Nat.pos_of_ne_zero n0
  have n_gt_0' : (0 : ‚Ñù) < (n : ‚Ñù) := Nat.cast_pos.mpr n_gt_0
  have n_ge_1 : 1 ‚â§ (n : ‚Ñù) := Nat.one_le_cast.mpr <| Nat.succ_le_of_lt n_gt_0
  calc
    _ = |((n : ‚Ñù) ^ (-œÉ))| := ?_
    _ ‚â§ Real.exp (Real.log n * -œÉ) := Real.abs_rpow_le_exp_log_mul (n : ‚Ñù) (-œÉ)
    _ ‚â§ Real.exp (Real.log n *  -(1 - A / Real.log t)) := ?_
    _ ‚â§ Real.exp (- Real.log n + A) := Real.exp_le_exp_of_le ?_
    _ ‚â§ _ := by rw [Real.exp_add, Real.exp_neg, Real.exp_log n_gt_0']
  ¬∑ have : ‚Äñ(n : ‚ÑÇ) ^ (-s)‚Äñ = n ^ (-s.re) := abs_cpow_eq_rpow_re_of_pos n_gt_0' (-s)
    rw [this, abs_eq_self.mpr <| Real.rpow_nonneg n_gt_0'.le _]; simp [s]
  ¬∑ apply Real.exp_le_exp_of_le <| mul_le_mul_of_nonneg_left _ <| Real.log_nonneg n_ge_1
    rw [neg_sub, neg_le_sub_iff_le_add, add_comm, ‚Üê Real.log_abs]; linarith
  ¬∑ simp only [neg_sub, le_neg_add_iff_add_le]
    ring_nf
    conv => rw [mul_comm, ‚Üê mul_assoc, ‚Üê Real.log_abs]; rhs; rw [‚Üê one_mul A]
    gcongr
    by_cases ht1 : |t| = 1; simp [ht1]
    apply (inv_mul_le_iff ?_).mpr; convert Real.log_le_log n_gt_0' n_le_t using 1; rw [mul_one]
    exact Real.log_pos <| lt_of_le_of_ne (le_trans n_ge_1 n_le_t) <| fun t ‚Ü¶ ht1 (t.symm)
/-%%
\begin{proof}\leanok
Use $|n^{-s}| = n^{-\sigma}
= e^{-\sigma \log n}
\le
\exp(-\left(1-\frac{A}{\log t}\right)\log n)
\le
n^{-1} e^A$,
since $n\le t$.
\end{proof}
%%-/

lemma UpperBnd_aux {A œÉ t: ‚Ñù} (A_pos : 0 < A) (A_lt : A < 1) (t_ge : 3 < |t|)
      (œÉ_ge : 1 - A / Real.log |t| ‚â§ œÉ) :
      1 < Real.log |t| ‚àß 1 - A < œÉ ‚àß 0 < œÉ ‚àß œÉ + t * I ‚â† 1:= by
  have logt_gt_one: 1 < Real.log |t| := by
    rw [‚Üê Real.log_exp (x := 1)]
    apply Real.log_lt_log (Real.exp_pos _)
    linarith [(by exact lt_trans Real.exp_one_lt_d9 (by norm_num) : Real.exp 1 < 3)]
  have œÉ_gt : 1 - A < œÉ := by
    apply lt_of_lt_of_le ((sub_lt_sub_iff_left (a := 1)).mpr ?_) œÉ_ge
    exact (div_lt_iff (by linarith)).mpr <| lt_mul_right A_pos logt_gt_one
  refine ‚ü®logt_gt_one, œÉ_gt, by linarith, ?__‚ü©
  contrapose! t_ge
  simp only [Complex.ext_iff, add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one,
    sub_self, add_zero, one_re, add_im, mul_im, zero_add, one_im] at t_ge
  norm_num [t_ge.2]

lemma UpperBnd_aux2 {A œÉ t: ‚Ñù} (A_pos : 0 < A) (A_lt : A < 1) (t_ge : 3 < |t|)
      (œÉ_ge : 1 - A / |t|.log ‚â§ œÉ) :
      |t| ^ (1 - œÉ) ‚â§ A.exp := by
  have : |t| ^ (1 - œÉ) ‚â§ |t| ^ (A / |t|.log) :=
    Real.rpow_le_rpow_of_exponent_le (by linarith) (by linarith)
  apply le_trans this ?_
  conv => lhs; lhs; rw [‚Üê Real.exp_log (by linarith : 0 < |t|)]
  rw [div_eq_mul_inv, Real.rpow_mul (by positivity), ‚Üê Real.exp_mul, ‚Üê Real.exp_mul, mul_comm,
    ‚Üê mul_assoc, inv_mul_cancel, one_mul]
  apply Real.log_ne_zero.mpr; split_ands <;> linarith

lemma riemannZeta0_zero_aux (N : ‚Ñï) (Npos : 0 < N):
    ‚àë x in Finset.Ico 0 N, ((x : ‚Ñù))‚Åª¬π = ‚àë x in Finset.Ico 1 N, ((x : ‚Ñù))‚Åª¬π := by
  have : Finset.Ico 1 N ‚äÜ Finset.Ico 0 N := by
    intro x hx
    simp only [Finset.mem_Ico, Nat.Ico_zero_eq_range, Finset.mem_range] at hx ‚ä¢
    exact hx.2
  rw [‚Üê Finset.sum_sdiff (s‚ÇÅ := Finset.Ico 1 N) (s‚ÇÇ := Finset.Ico 0 N) this]
  have : Finset.Ico 0 N \ Finset.Ico 1 N = Finset.range 1 := by
    ext a
    simp only [Nat.Ico_zero_eq_range, Finset.mem_sdiff, Finset.mem_range, Finset.mem_Ico, not_and,
      not_lt, Finset.range_one, Finset.mem_singleton]
    constructor
    ¬∑ intro ‚ü®ha‚ÇÅ, ha‚ÇÇ‚ü©; omega
    ¬∑ intro ha
      constructor
      ¬∑ simp [ha, Npos]
      ¬∑ omega
  rw [this]; simp

lemma UpperBnd_aux3 {A C œÉ t : ‚Ñù} (Apos : 0 < A) (A_lt_one : A < 1) {N : ‚Ñï} (Npos : 0 < N)
    (œÉ_ge : 1 - A / Real.log |t| ‚â§ œÉ) (t_ge : 3 < |t|) (N_le_t : (N : ‚Ñù) ‚â§ |t|) (hC : 2 ‚â§ C) :
     ‚Äñ‚àë n in Finset.range N, (n : ‚ÑÇ) ^ (-(œÉ + t * I))‚Äñ ‚â§ A.exp * C * |t|.log := by
  obtain ‚ü®logt_gt_one, _, œÉPos, _‚ü© := UpperBnd_aux Apos A_lt_one t_ge œÉ_ge
  have (n : ‚Ñï) (hn : n ‚àà Finset.range N) := ZetaBnd_aux2 (n := n) Apos œÉPos ?_ œÉ_ge
  swap; exact le_trans (Nat.cast_le.mpr (Finset.mem_range.mp hn).le) N_le_t
  replace := norm_sum_le_of_le (Finset.range N) this
  rw [‚Üê Finset.sum_mul, mul_comm _ A.exp] at this
  rw [mul_assoc]
  apply le_trans this <| (mul_le_mul_left A.exp_pos).mpr ?_
  have : 1 + (N - 1: ‚Ñù).log ‚â§ C * |t|.log := by
    by_cases hN : N = 1
    ¬∑ simp only [hN, Nat.cast_one, sub_self, Real.log_zero, add_zero];
      rw [‚Üê mul_one 1]; exact mul_le_mul (by linarith) logt_gt_one.le (by norm_num) (by positivity)
    ¬∑ rw [(by ring : C * Real.log |t| = (C - 1) * Real.log |t| + Real.log |t|)]
      replace hN : 0 < (N : ‚Ñù) - 1 := by simp only [sub_pos, Nat.one_lt_cast]; omega
      have : (N - 1: ‚Ñù).log ‚â§ |t|.log := Real.log_le_log hN (by linarith)
      apply add_le_add ?_ this
      nth_rewrite 1 [‚Üê mul_one 1]
      exact mul_le_mul (by linarith) logt_gt_one.le (by norm_num) (by linarith)
  refine le_trans ?_ this
  convert harmonic_eq_sum_Icc ‚ñ∏ harmonic_le_one_add_log (N - 1)
  ¬∑ simp only [Rat.cast_sum, Rat.cast_inv, Rat.cast_natCast, Finset.range_eq_Ico]
    rw [riemannZeta0_zero_aux N Npos]; congr! 1
  ¬∑ rw [Nat.cast_pred Npos]

lemma Nat.self_div_floor_bound {t : ‚Ñù}  (t_ge : 1 ‚â§ |t|) : (|t| / ‚Üë‚åä|t|‚åã‚Çä) ‚àà Icc 1 2 := by
  set N := ‚åä|t|‚åã‚Çä
  have Npos : 0 < N := Nat.floor_pos.mpr (by linarith)
  have N_le_t : N ‚â§ |t| := by exact Nat.floor_le <| abs_nonneg _
  constructor
  ¬∑ apply le_div_iff (by simp [Npos]) |>.mpr; simp [N_le_t]
  ¬∑ apply div_le_iff (by positivity) |>.mpr
    suffices |t| < ‚ÜëN + 1 by linarith [(by exact_mod_cast (by omega) : 1 ‚â§ (N : ‚Ñù))]
    apply Nat.lt_floor_add_one

lemma le_trans‚ÇÑ {Œ± : Type*} [Preorder Œ±] {a b c d: Œ±} : a ‚â§ b ‚Üí b ‚â§ c ‚Üí c ‚â§ d ‚Üí a ‚â§ d :=
  fun hab hbc hcd ‚Ü¶ le_trans (le_trans hab hbc) hcd

lemma UpperBnd_aux5 {œÉ t : ‚Ñù}  (t_ge : 3 < |t|) (œÉ_le : œÉ ‚â§ 2) : (|t| / ‚åä|t|‚åã‚Çä) ^ œÉ ‚â§ 4 := by
  obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := Nat.self_div_floor_bound (by linarith)
  refine le_trans‚ÇÑ (c := 2 ^ 2) ?_ (Real.rpow_le_rpow (by linarith) h‚ÇÇ (by norm_num)) (by norm_num)
  exact (Real.rpow_le_rpow_of_exponent_le h‚ÇÅ œÉ_le)

lemma UpperBnd_aux6 {œÉ t : ‚Ñù} (t_ge : 3 < |t|) (œÉ_gt : 1 / 2 < œÉ) (œÉ_le : œÉ ‚â§ 2)
  (neOne : œÉ + t * I ‚â† 1) (Npos : 0 < ‚åä|t|‚åã‚Çä) (N_le_t : ‚åä|t|‚åã‚Çä ‚â§ |t|) :
    ‚åä|t|‚åã‚Çä ^ (1 - œÉ) / ‚Äñ1 - (œÉ + t * I)‚Äñ ‚â§ |t| ^ (1 - œÉ) * 2 ‚àß
    ‚åä|t|‚åã‚Çä ^ (-œÉ) / 2 ‚â§ |t| ^ (1 - œÉ) ‚àß ‚åä|t|‚åã‚Çä ^ (-œÉ) / œÉ ‚â§ 8 * |t| ^ (-œÉ) := by
  have bnd := UpperBnd_aux5 t_ge œÉ_le
  have bnd' : (|t| / ‚åä|t|‚åã‚Çä) ^ œÉ ‚â§ 2 * |t| := by linarith
  split_ands
  ¬∑ apply (div_le_iff <| norm_pos_iff.mpr <| sub_ne_zero_of_ne neOne.symm).mpr
    conv => rw [mul_assoc]; rhs; rw [mul_comm]
    apply (div_le_iff <| Real.rpow_pos_of_pos (by linarith) _).mp
    rw [div_rpow_eq_rpow_div_neg (by positivity) (by positivity), neg_sub]
    refine le_trans‚ÇÑ ?_ bnd' ?_
    ¬∑ exact Real.rpow_le_rpow_of_exponent_le (one_le_div (by positivity) |>.mpr N_le_t) (by simp)
    ¬∑ apply (mul_le_mul_left (by norm_num)).mpr; simpa using abs_im_le_abs (1 - (œÉ + t * I))
  ¬∑ apply div_le_iff (by norm_num) |>.mpr
    rw [Real.rpow_sub (by linarith), Real.rpow_one, div_mul_eq_mul_div, mul_comm]
    apply div_le_iff (by positivity) |>.mp
    convert bnd' using 1
    rw [‚Üê Real.rpow_neg (by linarith), div_rpow_neg_eq_rpow_div (by positivity) (by positivity)]
  ¬∑ apply div_le_iff (by positivity) |>.mpr
    rw [mul_assoc, mul_comm, mul_assoc]
    apply div_le_iff' (by positivity) |>.mp
    apply le_trans ?_ (by linarith : 4 ‚â§ œÉ * 8)
    convert bnd using 1; exact div_rpow_neg_eq_rpow_div (by positivity) (by positivity)

lemma norm_add‚ÇÑ_le {E: Type*} [SeminormedAddGroup E] (a : E) (b : E) (c : E) (d : E) :
    ‚Äña + b + c + d‚Äñ ‚â§ ‚Äña‚Äñ + ‚Äñb‚Äñ + ‚Äñc‚Äñ + ‚Äñd‚Äñ := by
  apply le_trans <| norm_add_le (a + b + c) d
  simp only [add_le_add_iff_right]; apply norm_add‚ÇÉ_le

lemma add_le_add_le_add {Œ± : Type*} [Add Œ±] [Preorder Œ±]
    [CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1]
    [CovariantClass Œ± Œ± (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1]
    {a b c d e f : Œ±} (h‚ÇÅ : a ‚â§ b) (h‚ÇÇ : c ‚â§ d) (h‚ÇÉ : e ‚â§ f) : a + c + e ‚â§ b + d + f :=
  add_le_add (add_le_add h‚ÇÅ h‚ÇÇ) h‚ÇÉ

lemma add_le_add_le_add_le_add {Œ± : Type*} [Add Œ±] [Preorder Œ±]
    [CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1]
    [CovariantClass Œ± Œ± (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1]
    {a b c d e f g h : Œ±} (h‚ÇÅ : a ‚â§ b) (h‚ÇÇ : c ‚â§ d) (h‚ÇÉ : e ‚â§ f) (h‚ÇÑ : g ‚â§ h) :
    a + c + e + g ‚â§ b + d + f + h:= add_le_add (add_le_add_le_add h‚ÇÅ h‚ÇÇ h‚ÇÉ) h‚ÇÑ

/-%%
\begin{lemma}[ZetaUpperBnd]\label{ZetaUpperBnd}\lean{ZetaUpperBnd}\leanok
For any $s\in \C$, $1/2 \le \Re(s)=\sigma\le 2$,
and any $0 < A < 1$ sufficiently small, and $1-A/\log |t| \le \sigma$, we have
$$
|\zeta(s)| \ll \log t,
$$
as $|t|\to\infty$.
\end{lemma}
%%-/
lemma ZetaUpperBnd :
    ‚àÉ (A : ‚Ñù) (Apos : 0 < A) (C : ‚Ñù) (Cpos : 0 < C), ‚àÄ (œÉ : ‚Ñù) (t : ‚Ñù) (t_ge : ct_aux1 < |t|)
    (_ : œÉ ‚àà Icc (1 - A / |t|.log) 2), ‚ÄñŒ∂ (œÉ + t * I)‚Äñ ‚â§ C * |t|.log := by
  let A := (1 : ‚Ñù) / 2
  have Apos : 0 < A := by norm_num
  let C := A.exp * (5 + 8 * C_aux1)
  refine ‚ü®A, Apos, C, (by positivity), ?_‚ü©
  intro œÉ t t_ge ‚ü®œÉ_ge, œÉ_le‚ü©
  have t_ge' : 3 < |t| := lt_trans (by norm_num [ct_aux1]) t_ge
  set N := ‚åä|t|‚åã‚Çä
  have Npos : 0 < N := Nat.floor_pos.mpr (by linarith)
  have N_le_t : N ‚â§ |t| := Nat.floor_le <| abs_nonneg _
  obtain ‚ü®logt_gt_one, œÉ_gt, œÉPos, neOne‚ü© := UpperBnd_aux Apos (by norm_num) t_ge' œÉ_ge
  norm_num [A] at œÉ_gt
  rw [‚Üê Zeta0EqZeta (N := N) Npos (by simp [œÉPos]) neOne]
  set s := œÉ + t * I
  calc
    _ ‚â§ ‚Äñ‚àë n in Finset.range N, 1 / (n : ‚ÑÇ) ^ s‚Äñ + ‚Äñ(- N ^ (1 - s)) / (1 - s)‚Äñ +
      ‚Äñ(-(N : ‚ÑÇ) ^ (-s)) / 2‚Äñ +
      ‚Äñs * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ := by apply norm_add‚ÇÑ_le
    _ ‚â§ A.exp * 2 * |t|.log + ‚Äñ(- N ^ (1 - s)) / (1 - s)‚Äñ + ‚Äñ(-(N : ‚ÑÇ) ^ (-s)) / 2‚Äñ +
      ‚Äñs * ‚à´ x in Ioi (N : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) / (x : ‚ÑÇ) ^ (s + 1)‚Äñ := ?_
    _ ‚â§ A.exp * 2 * |t|.log + ‚Äñ(- N ^ (1 - s)) / (1 - s)‚Äñ + ‚Äñ(-(N : ‚ÑÇ) ^ (-s)) / 2‚Äñ +
      C_aux1 * |t| * N ^ (-œÉ) / œÉ  := ?_
    _ = A.exp * 2 * |t|.log + N ^ (1 - œÉ) / ‚Äñ(1 - s)‚Äñ + N ^ (-œÉ) / 2 +
      C_aux1 * |t| * N ^ (-œÉ) / œÉ  := ?_
    _ ‚â§ A.exp * 2 * |t|.log + |t| ^ (1 - œÉ) * 2 +
        |t| ^ (1 - œÉ) + C_aux1 * |t| * (8 * |t| ^ (-œÉ)) := ?_
    _ = A.exp * 2 * |t|.log + (3 + 8 * C_aux1) * |t| ^ (1 - œÉ) := ?_
    _ ‚â§ A.exp * 2 * |t|.log + (3 + 8 * C_aux1) * A.exp * 1 := ?_
    _ ‚â§ A.exp * 2 * |t|.log + (3 + 8 * C_aux1) * A.exp * |t|.log:= ?_
    _ = _ := by ring
  ¬∑ simp only [add_le_add_iff_right, one_div_cpow_eq_cpow_neg]
    convert UpperBnd_aux3 (C := 2) Apos (by norm_num) Npos œÉ_ge t_ge' N_le_t le_rfl
  ¬∑ simp only [add_le_add_iff_left]; exact ZetaBnd_aux1 N (by linarith) ‚ü®œÉPos, œÉ_le‚ü© t t_ge
  ¬∑ simp only [norm_div, norm_neg, norm_eq_abs, RCLike.norm_ofNat, Nat.abs_cast, s]
    congr <;> (convert norm_natCast_cpow_of_pos Npos _; simp)
  ¬∑ have ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := UpperBnd_aux6 t_ge' œÉ_gt œÉ_le neOne Npos N_le_t
    refine add_le_add_le_add_le_add le_rfl h‚ÇÅ h‚ÇÇ ?_
    rw [mul_div_assoc]
    exact mul_le_mul_left (mul_pos (by norm_num [C_aux1]) (by positivity)) |>.mpr h‚ÇÉ
  ¬∑ ring_nf; conv => lhs; rhs; lhs; rw [mul_assoc, mul_comm |t|]
    rw [‚Üê Real.rpow_add_one (by positivity)]; ring_nf
  ¬∑ simp only [Real.log_abs, add_le_add_iff_left, mul_one]
    exact mul_le_mul_left (by positivity) |>.mpr <| UpperBnd_aux2 Apos (by norm_num) t_ge' œÉ_ge
  ¬∑ simp only [add_le_add_iff_left]
    apply mul_le_mul_left (by norm_num [Real.exp_pos, C_aux1]) |>.mpr <| logt_gt_one.le
/-%%
\begin{proof}\uses{ZetaBnd_aux1, ZetaBnd_aux2, Zeta0EqZeta}\leanok
First replace $\zeta(s)$ by $\zeta_0(N,s)$ for $N = \lfloor |t| \rfloor$.
We estimate:
$$
|\zeta_0(N,s)| \ll
\sum_{1\le n < |t|} |n^{-s}|
+
\frac{- |t|^{1-\sigma}}{|1-s|} + \frac{-|t|^{-\sigma}}{2} +
|t| \cdot |t| ^ (-œÉ) / œÉ
$$
$$
\ll
e^A \sum_{1\le n < |t|} n^{-1}
+|t|^{1-\sigma}
$$
,
where we used Lemma \ref{ZetaBnd_aux2} and Lemma \ref{ZetaBnd_aux1}.
The first term is $\ll \log |t|$.
For the second term, estimate
$$
|t|^{1-\sigma}
\le |t|^{1-(1-A/\log |t|)}
= |t|^{A/\log |t|} \ll 1.
$$
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaDerivUpperBnd]\label{ZetaDerivUpperBnd}\lean{ZetaDerivUpperBnd}\leanok
For any $s\in \C$, $1/2 \le \Re(s)=\sigma\le 2$,
there is an $A>0$ so that for $1-A/\log t \le \sigma$, we have
$$
|\zeta'(s)| \ll \log^2 t,
$$
as $|t|\to\infty$.
\end{lemma}
%%-/
lemma ZetaDerivUpperBnd :
    ‚àÉ (A : ‚Ñù) (Apos : 0 < A) (C : ‚Ñù) (Cpos : 0 < C), ‚àÄ (œÉ : ‚Ñù) (t : ‚Ñù) (t_gt : 3 < |t|)
    (hœÉ : œÉ ‚àà Icc (1 - A / Real.log |t|) 2),
    ‚Äñderiv Œ∂ (œÉ + t * I)‚Äñ ‚â§ C * (Real.log |t|) ^ 2 := by
  let A := (1 : ‚Ñù) / 2
  have Apos : 0 < A := by norm_num
  refine ‚ü®A, Apos, 10, by norm_num, ?_‚ü©
  intro œÉ t t_ge ‚ü®œÉ_ge, œÉ_le‚ü©
  set N := ‚åä|t|‚åã‚Çä
  set s := œÉ + t * I
  obtain ‚ü®logt_gt_one, œÉ_gt, œÉPos, neOne‚ü© := UpperBnd_aux Apos (by norm_num) t_ge œÉ_ge
  have : deriv Œ∂ s = deriv (Œ∂‚ÇÄ N) s := by
    have := Zeta0EqZeta (N := N) (Nat.floor_pos.mpr (by linarith)) (by simp [œÉPos]) neOne
    -- these functions agree on an open set, their derivatives agree there too
    sorry
  rw [this]
  -- use calc similar to the one for ZetaUpperBnd
  sorry
/-%%
\begin{proof}\uses{ZetaBnd_aux1, ZetaBnd_aux2, Zeta0EqZeta}
First replace $\zeta(s)$ by $\zeta_0(N,s)$ for $N = \lfloor |t| \rfloor$.
Differentiating term by term, we get:
$$
\zeta'(s) = -\sum_{1\le n < N} n^{-s} \log n
-
\frac{N^{1 - s}}{1 - s)^2} + \frac{N^{1 - s} \log N} {1 - s}
+ \frac{-N^{-s}\log N}{2} +
\int_N^\infty \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+1}} \, dx
-
s(s+1) \int_N^\infty \frac{\lfloor x\rfloor + 1/2 - x}{x^{s+2}} \, dx
.
$$
Estimate as before, with an extra factor of $\log |t|$.
\end{proof}
%%-/

lemma Tendsto_nhdsWithin_punctured_map_add {f : ‚Ñù ‚Üí ‚Ñù} (a x : ‚Ñù)
    (f_mono : StrictMono f) (f_iso : Isometry f):
    Tendsto (fun y ‚Ü¶ f y + a) (ùìù[>] x) (ùìù[>] (f x + a)) := by
  refine tendsto_iff_forall_eventually_mem.mpr ?_
  intro v hv
  simp only [mem_nhdsWithin] at hv
  obtain ‚ü®u, hu, hu2, hu3‚ü© := hv
  let t := {x | f x + a ‚àà u}
  have : t ‚à© Ioi x ‚àà ùìù[>] x := by
    simp only [mem_nhdsWithin]
    use t
    simp only [subset_inter_iff, inter_subset_left, inter_subset_right, and_self,
      and_true, t]
    simp
    refine ‚ü®?_, by simp [hu2]‚ü©
    simp [Metric.isOpen_iff] at hu ‚ä¢
    intro x hx
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© := hu (f x + a) hx
    simp only [Metric.ball, dist_sub_eq_dist_add_right, setOf_subset_setOf] at hŒµ ‚ä¢
    exact ‚ü®Œµ, Œµpos, fun _ hy ‚Ü¶ hŒµ (by simp [isometry_iff_dist_eq.mp f_iso, hy])‚ü©
  filter_upwards [this]
  intro b hb
  simp only [mem_inter_iff, mem_setOf_eq, mem_Ioi, t] at hb
  refine hu3 ?_
  simp only [mem_inter_iff, mem_Ioi, add_lt_add_iff_right]
  exact ‚ü®hb.1, f_mono hb.2‚ü©

lemma Tendsto_nhdsWithin_punctured_add (a x : ‚Ñù) :
    Tendsto (fun y ‚Ü¶ y + a) (ùìù[>] x) (ùìù[>] (x + a)) :=
  Tendsto_nhdsWithin_punctured_map_add a x strictMono_id isometry_id

/-%%
\begin{lemma}[ZetaNear1BndFilter]\label{ZetaNear1BndFilter}\lean{ZetaNear1BndFilter}\leanok
As $\sigma\to1^+$,
$$
|\zeta(\sigma)| \ll 1/(\sigma-1).
$$
\end{lemma}
%%-/
lemma ZetaNear1BndFilter:
    (fun œÉ : ‚Ñù ‚Ü¶ Œ∂ œÉ) =O[ùìù[>](1 : ‚Ñù)] (fun œÉ ‚Ü¶ (1 : ‚ÑÇ) / (œÉ - 1)) := by
  have := Tendsto_nhdsWithin_punctured_add (a := -1) (x := 1)
  simp only [add_right_neg, ‚Üê sub_eq_add_neg] at this
  have := riemannZeta_isBigO_near_one_horizontal.comp_tendsto this
  convert this using 1 <;> {ext; simp}
/-%%
\begin{proof}\uses{ZetaBnd_aux1, Zeta0EqZeta}\leanok
Zeta has a simple pole at $s=1$. Equivalently, $\zeta(s)(s-1)$ remains bounded near $1$.
Lots of ways to prove this.
Probably the easiest one: use the expression for $\zeta_0 (N,s)$ with $N=1$ (the term $N^{1-s}/(1-s)$ being the only unbounded one).
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaNear1BndExact]\label{ZetaNear1BndExact}\lean{ZetaNear1BndExact}\leanok
There exists a $c>0$ such that for all $1 < \sigma ‚â§ 2$,
$$
|\zeta(\sigma)| ‚â§ c/(\sigma-1).
$$
\end{lemma}
%%-/
lemma ZetaNear1BndExact:
    ‚àÉ (c : ‚Ñù) (cpos : 0 < c), ‚àÄ (œÉ : ‚Ñù) (_ : œÉ ‚àà Ioc 1 2), ‚ÄñŒ∂ œÉ‚Äñ ‚â§ c / (œÉ - 1) := by
  have := ZetaNear1BndFilter
  rw [Asymptotics.isBigO_iff] at this
  obtain ‚ü®c, U, hU, V, hV, h‚ü© := this
  obtain ‚ü®T, hT, T_open, h1T‚ü© := mem_nhds_iff.mp hU
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© := Metric.isOpen_iff.mp T_open 1 h1T
  simp only [Metric.ball] at hŒµ
  replace hŒµ : Ico 1 (1 + Œµ) ‚äÜ U := by
    refine subset_trans (subset_trans ?_ hŒµ) hT
    intro x hx
    simp only [mem_Ico] at hx
    simp only [dist, abs_lt]
    exact ‚ü®by linarith, by linarith‚ü©
  let W := Icc (1 + Œµ) 2
  have W_compact : IsCompact {ofReal' z | z ‚àà W} :=
    IsCompact.image isCompact_Icc continuous_ofReal
  have cont : ContinuousOn Œ∂ {ofReal' z | z ‚àà W} := by
    apply HasDerivAt.continuousOn (f' := deriv Œ∂)
    intro œÉ hœÉ
    exact (differentiableAt_riemannZeta (by contrapose! hœÉ; simp [W, hœÉ, Œµpos])).hasDerivAt
  obtain ‚ü®C, hC‚ü© := IsCompact.exists_bound_of_continuousOn W_compact cont
  let C' := max (C + 1) 1
  replace hC : ‚àÄ (œÉ : ‚Ñù), œÉ ‚àà W ‚Üí ‚ÄñŒ∂ œÉ‚Äñ < C' := by
    intro œÉ hœÉ
    simp only [lt_max_iff, C']
    have := hC œÉ
    simp only [mem_setOf_eq, ofReal_inj, exists_eq_right] at this
    exact Or.inl <| lt_of_le_of_lt (this hœÉ) (by norm_num)
  have Cpos : 0 < C' := by simp [C']
  use max (2 * C') c, (by simp [Cpos])
  intro œÉ ‚ü®œÉ_ge, œÉ_le‚ü©
  by_cases hœÉ : œÉ ‚àà U ‚à© V
  ¬∑ simp only [‚Üê h, mem_setOf_eq] at hœÉ
    apply le_trans hœÉ ?_
    norm_cast
    have : 0 ‚â§ 1 / (œÉ - 1) := by apply one_div_nonneg.mpr; linarith
    simp only [norm_eq_abs, Complex.abs_ofReal, abs_eq_self.mpr this, mul_div, mul_one]
    exact div_le_div (by simp [Cpos.le]) (by simp) (by linarith) (by rfl)
  ¬∑ replace hœÉ : œÉ ‚àà W := by
      simp only [mem_inter_iff, hV œÉ_ge, and_true] at hœÉ
      simp only [mem_Icc, œÉ_le, and_true, W]
      contrapose! hœÉ; exact hŒµ ‚ü®œÉ_ge.le, hœÉ‚ü©
    apply le_trans (hC œÉ hœÉ).le ((le_div_iff (by linarith)).mpr ?_)
    rw [le_max_iff, mul_comm 2]; exact Or.inl <| mul_le_mul_of_nonneg_left (by linarith) Cpos.le
/-%%
\begin{proof}\uses{ZetaNear1BndFilter}\leanok
Split into two cases, use Lemma \ref{ZetaNear1BndFilter} for $\sigma$ sufficiently small
and continuity on a compact interval otherwise.
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaInvBound1]\label{ZetaInvBound1}\lean{ZetaInvBound1}\leanok
For all $\sigma>1$,
$$
1/|\zeta(\sigma+it)| \le |\zeta(\sigma)|^{3/4}|\zeta(\sigma+2it)|^{1/4}
$$
\end{lemma}
%%-/
lemma ZetaInvBound1 {œÉ t : ‚Ñù} (œÉ_gt : 1 < œÉ) :
    1 / ‚ÄñŒ∂ (œÉ + t * I)‚Äñ ‚â§ ‚ÄñŒ∂ œÉ‚Äñ ^ ((3 : ‚Ñù) / 4) * ‚ÄñŒ∂ (œÉ + 2 * t * I)‚Äñ ^ ((1 : ‚Ñù) / 4) := by
  apply (div_le_iff ?_).mpr
  apply (Real.rpow_le_rpow_iff (z := 4) (by norm_num) ?_ (by norm_num)).mp
  ¬∑ simp only [Real.one_rpow]
    rw [Real.mul_rpow, Real.mul_rpow, ‚Üê Real.rpow_mul, ‚Üê Real.rpow_mul]
    simp only [isUnit_iff_ne_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      IsUnit.div_mul_cancel, IsUnit.inv_mul_cancel, Real.rpow_one]
    conv => rw [mul_assoc]; rhs; rhs; rw [mul_comm]
    rw [‚Üê mul_assoc]
    have := norm_zeta_product_ge_one (x := œÉ - 1) (by linarith) t
    simp_rw [ge_iff_le, norm_mul, norm_pow, ofReal_sub, ofReal_one, add_sub_cancel, ‚Üê Real.rpow_nat_cast] at this
    convert this using 3 <;> ring_nf
    any_goals ring_nf
    any_goals apply norm_nonneg
    any_goals apply Real.rpow_nonneg <| norm_nonneg _
    apply mul_nonneg <;> apply Real.rpow_nonneg <| norm_nonneg _
  ¬∑ refine mul_nonneg (mul_nonneg ?_ ?_) ?_ <;> simp [Real.rpow_nonneg]
  ¬∑ have s_ne_one : œÉ + t * I ‚â† 1 := by
      contrapose! œÉ_gt; apply le_of_eq; apply And.left; simpa [Complex.ext_iff] using œÉ_gt
    have zeta_ne_zero:= riemannZeta_ne_zero_of_one_le_re s_ne_one (by simp [œÉ_gt.le])
    suffices 0 ‚â§ ‚ÄñŒ∂ (‚ÜëœÉ + ‚Üët * I)‚Äñ by simp [le_iff_lt_or_eq.mp this, zeta_ne_zero]
    apply norm_nonneg
/-%%
\begin{proof}\leanok
The identity
$$
1 \le |\zeta(\sigma)|^3 |\zeta(\sigma+it)|^4 |\zeta(\sigma+2it)|
$$
for $\sigma>1$
is already proved by Michael Stoll in the EulerProducts PNT file.
\end{proof}
%%-/

lemma Ioi_union_Iio_mem_cocompact {a : ‚Ñù} (ha : 0 ‚â§ a) : Ioi (a : ‚Ñù) ‚à™ Iio (-a : ‚Ñù) ‚àà cocompact ‚Ñù := by
  simp only [Filter.mem_cocompact]
  use Icc (-a) a
  constructor
  ¬∑ exact isCompact_Icc
  ¬∑ rw [@compl_subset_iff_union, ‚Üê union_assoc, Icc_union_Ioi_eq_Ici, union_comm, Iio_union_Ici]
    linarith

lemma lt_abs_mem_cocompact {a : ‚Ñù} (ha : 0 ‚â§ a) : {t | a < |t|} ‚àà cocompact ‚Ñù := by
  convert Ioi_union_Iio_mem_cocompact ha using 1; ext t
  simp only [mem_setOf_eq, mem_union, mem_Ioi, mem_Iio, lt_abs, lt_neg]

/-%%
\begin{lemma}[ZetaInvBound2]\label{ZetaInvBound2}\lean{ZetaInvBound2}\leanok
For $\sigma>1$ (and $\sigma \le 2$),
$$
1/|\zeta(\sigma+it)| \ll (\sigma-1)^{-3/4}(\log |t|)^{1/4},
$$
as $|t|\to\infty$.
\end{lemma}
%%-/
lemma ZetaInvBound2 {œÉ : ‚Ñù} (hœÉ : œÉ ‚àà Ioc 1 2) :
    (fun (t : ‚Ñù) ‚Ü¶ 1 / ‚ÄñŒ∂ (œÉ + t * I)‚Äñ) =O[cocompact ‚Ñù]
      fun (t : ‚Ñù) ‚Ü¶ (œÉ - 1) ^ (-(3 : ‚Ñù) / 4) * (Real.log |t|) ^ ((1 : ‚Ñù) / 4) := by
  obtain ‚ü®A, ha, C, hC, h‚ü© := ZetaUpperBnd
  obtain ‚ü®c, hc, h_inv‚ü© := ZetaNear1BndExact
  obtain ‚ü®œÉ_gt, œÉ_le‚ü© := hœÉ
  rw [Asymptotics.isBigO_iff]
  use (2 * C) ^ ((1 : ‚Ñù)/ 4) * c ^ ((3 : ‚Ñù)/ 4)
  filter_upwards [lt_abs_mem_cocompact (by norm_num [ct_aux1] : 0 ‚â§ (ct_aux1 : ‚Ñù) / 2)] with t ht
  have ht' : ct_aux1 < |2 * t| := by
    convert div_lt_iff' (by positivity) |>.mp ht using 1; simp [abs_mul]
  norm_num [ct_aux1] at ht ht'
  have hnezero: ((œÉ - 1) / c) ^ (-3 / 4 : ‚Ñù) ‚â† 0 := by
    have : (œÉ - 1) / c ‚â† 0 := ne_of_gt <| div_pos (by linarith) hc
    contrapose! this
    rwa [Real.rpow_eq_zero (div_nonneg (by linarith) hc.le) (by norm_num)] at this
  calc
    _ ‚â§ ‚Äñ‚ÄñŒ∂ œÉ‚Äñ ^ (3 / 4 : ‚Ñù) * ‚ÄñŒ∂ (‚ÜëœÉ + 2 * ‚Üët * I)‚Äñ ^ (1 / 4 : ‚Ñù)‚Äñ := ?_
    _ ‚â§ ‚Äñ((œÉ - 1) / c) ^ (-3 / 4 : ‚Ñù) * ‚ÄñŒ∂ (‚ÜëœÉ + 2 * ‚Üët * I)‚Äñ ^ (1 / 4 : ‚Ñù)‚Äñ := ?_
    _ ‚â§ ‚Äñ((œÉ - 1) / c) ^ (-3 / 4 : ‚Ñù) * C ^ (1 / 4 : ‚Ñù) * (Real.log |2 * t|) ^ (1 / 4 : ‚Ñù)‚Äñ := ?_
    _ ‚â§ ‚Äñ((œÉ - 1) / c) ^ (-3 / 4 : ‚Ñù) * C ^ (1 / 4 : ‚Ñù) * (Real.log (|t| ^ 2)) ^ (1 / 4 : ‚Ñù)‚Äñ := ?_
    _ = ‚Äñ((œÉ - 1)) ^ (-3 / 4 : ‚Ñù) * c ^ (3 / 4 : ‚Ñù) * (C ^ (1 / 4 : ‚Ñù) * (Real.log (|t| ^ 2)) ^ (1 / 4 : ‚Ñù))‚Äñ := ?_
    _ = ‚Äñ((œÉ - 1)) ^ (-3 / 4 : ‚Ñù) * c ^ (3 / 4 : ‚Ñù) * ((2 * C) ^ (1 / 4 : ‚Ñù) * Real.log |t| ^ (1 / 4 : ‚Ñù))‚Äñ := ?_
    _ = _ := ?_
  ¬∑ simp only [norm_div, norm_one, norm_mul, norm_norm]
    convert ZetaInvBound1 œÉ_gt using 2
    <;> exact abs_eq_self.mpr <| Real.rpow_nonneg (apply_nonneg _ _) _
  ¬∑ have bnd1: ‚ÄñŒ∂ œÉ‚Äñ ^ (3 / 4 : ‚Ñù) ‚â§ ((œÉ - 1) / c) ^ (-(3 : ‚Ñù) / 4) := by
      have : ((œÉ - 1) / c) ^ (-(3 : ‚Ñù) / 4) = (((œÉ - 1) / c) ^ (-1 : ‚Ñù)) ^ (3 / 4 : ‚Ñù) := by
        rw [‚Üê Real.rpow_mul ?_]; ring_nf; exact div_nonneg (by linarith) hc.le
      rw [this]
      apply Real.rpow_le_rpow (by simp [apply_nonneg]) ?_ (by norm_num)
      convert h_inv œÉ ‚ü®œÉ_gt, œÉ_le‚ü© using 1; simp [Real.rpow_neg_one, inv_div]
    simp only [norm_div, norm_one, norm_mul]
    apply (mul_le_mul_right ?_).mpr
    convert bnd1 using 1
    ¬∑ exact abs_eq_self.mpr <| Real.rpow_nonneg (apply_nonneg _ _) _
    ¬∑ exact abs_eq_self.mpr <| Real.rpow_nonneg (div_nonneg (by linarith) hc.le) _
    ¬∑ apply lt_iff_le_and_ne.mpr ‚ü®(by simp), ?_‚ü©
      have : Œ∂ (‚ÜëœÉ + 2 * ‚Üët * I) ‚â† 0 := by
        apply riemannZeta_ne_zero_of_one_le_re ?_ (by simp [œÉ_gt.le])
        contrapose! œÉ_gt; apply le_of_eq; apply And.left; simpa [Complex.ext_iff] using œÉ_gt
      symm; exact fun h2 ‚Ü¶ this (by simpa using h2)
  ¬∑ replace h := h œÉ (2 * t) (by simp [ct_aux1, ht']) ‚ü®?_, œÉ_le‚ü©
    ¬∑ have : 0 ‚â§ Real.log |2 * t| := Real.log_nonneg (by linarith)
      conv => rhs; rw [mul_assoc, ‚Üê Real.mul_rpow hC.le this]
      rw [norm_mul, norm_mul]
      conv => rhs; rhs; rw [Real.norm_rpow_of_nonneg <| mul_nonneg hC.le this]
      conv => lhs; rhs; rw [Real.norm_rpow_of_nonneg <| norm_nonneg _]
      apply (mul_le_mul_left ?_).mpr
      apply Real.rpow_le_rpow (norm_nonneg _) ?_ (by norm_num)
      ¬∑ convert h using 1; simp
        rw [Real.norm_eq_abs, abs_eq_self.mpr <| mul_nonneg hC.le this]
      ¬∑ simpa only [Real.norm_eq_abs, abs_pos]
    ¬∑ linarith [(div_nonneg ha.le (Real.log_nonneg (by linarith)) : 0 ‚â§ A / Real.log |2 * t|)]
  ¬∑ simp only [Real.log_abs, norm_mul]
    apply (mul_le_mul_left ?_).mpr
    ¬∑ rw [‚Üê Real.log_abs, Real.norm_rpow_of_nonneg <| Real.log_nonneg (by linarith)]
      have : 1 ‚â§ |(|t| ^ 2)| := by
        simp only [_root_.sq_abs, _root_.abs_pow, one_le_sq_iff_one_le_abs]
        linarith
      conv => rhs; rw [‚Üê Real.log_abs, Real.norm_rpow_of_nonneg <| Real.log_nonneg this]
      apply Real.rpow_le_rpow (abs_nonneg _) ?_ (by norm_num)
      ¬∑ rw [Real.norm_eq_abs, abs_eq_self.mpr <| Real.log_nonneg (by linarith)]
        rw [abs_eq_self.mpr <| Real.log_nonneg this, abs_mul, Real.log_abs, Nat.abs_ofNat]
        apply Real.log_le_log (mul_pos (by norm_num) (by linarith)) (by nlinarith)
    . apply mul_pos (abs_pos.mpr hnezero) (abs_pos.mpr ?_)
      have : C ‚â† 0 := ne_of_gt hC
      contrapose! this; rwa [Real.rpow_eq_zero (by linarith) (by norm_num)] at this
  ¬∑ have : (-3 : ‚Ñù) / 4 = -((3 : ‚Ñù)/ 4) := by norm_num
    simp only [norm_mul, mul_eq_mul_right_iff, abs_eq_zero, this, ‚Üê mul_assoc]; left; left
    conv => lhs; rw [Real.div_rpow (by linarith) hc.le, Real.rpow_neg hc.le, div_inv_eq_mul, norm_mul]
  ¬∑ simp only [Real.log_pow, Nat.cast_ofNat, norm_mul, Real.norm_eq_abs]
    congr! 1
    rw [Real.mul_rpow (by norm_num) hC.le, Real.mul_rpow (by norm_num) <|
        Real.log_nonneg (by linarith), abs_mul, abs_mul, ‚Üê mul_assoc, mul_comm _ |2 ^ (1 / 4)|]
  ¬∑ simp only [norm_mul, Real.norm_eq_abs]
    have : (2 * C) ^ ((1 : ‚Ñù)/ 4) * c ^ ((3 : ‚Ñù)/ 4) =|(2 * C) ^ ((1 : ‚Ñù)/ 4) * c ^ ((3 : ‚Ñù)/ 4)| := by
      rw [abs_eq_self.mpr (by apply mul_nonneg <;> (apply Real.rpow_nonneg; linarith))]
    rw [this, abs_mul]; ring
/-%%
\begin{proof}\uses{ZetaInvBound1, ZetaNear1BndExact, ZetaUpperBnd}\leanok
Combine Lemma \ref{ZetaInvBound1} with the bounds in Lemmata \ref{ZetaNear1BndExact} and
\ref{ZetaUpperBnd}.
\end{proof}
%%-/

lemma deriv_fun_re {t : ‚Ñù} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (diff : ‚àÄ (œÉ : ‚Ñù), DifferentiableAt ‚ÑÇ f (‚ÜëœÉ + ‚Üët * I)) :
    (deriv fun {œÉ‚ÇÇ : ‚Ñù} ‚Ü¶ f (œÉ‚ÇÇ + t * I)) = fun (œÉ : ‚Ñù) ‚Ü¶ deriv f (œÉ + t * I) := by
  ext œÉ
  have := deriv.comp (h := fun (œÉ : ‚Ñù) ‚Ü¶ œÉ + t * I) (h‚ÇÇ := f) œÉ (diff œÉ) ?_
  ¬∑ simp only [deriv_add_const', _root_.deriv_ofReal, mul_one] at this
    rw [‚Üê this]
    rfl
  ¬∑ apply DifferentiableAt.add_const <| differentiableAt_ofReal œÉ

/-%%
\begin{lemma}[Zeta_eq_int_derivZeta]\label{Zeta_eq_int_derivZeta}\lean{Zeta_eq_int_derivZeta}
\leanok
For any $t\ne0$ (so we don't pass through the pole), and $\sigma_1 < \sigma_2$,
$$
\int_{\sigma_1}^{\sigma_2}\zeta'(\sigma + it) dt =
\zeta(\sigma_2+it) - \zeta(\sigma_1+it).
$$
\end{lemma}
%%-/
lemma Zeta_eq_int_derivZeta {œÉ‚ÇÅ œÉ‚ÇÇ t : ‚Ñù} (t_ne_zero : t ‚â† 0) :
    (‚à´ œÉ in œÉ‚ÇÅ..œÉ‚ÇÇ, deriv Œ∂ (œÉ + t * I)) = Œ∂ (œÉ‚ÇÇ + t * I) - Œ∂ (œÉ‚ÇÅ + t * I) := by
  have diff : ‚àÄ (œÉ : ‚Ñù), DifferentiableAt ‚ÑÇ Œ∂ (œÉ + t * I) := by
    intro œÉ
    refine differentiableAt_riemannZeta ?_
    contrapose! t_ne_zero; apply And.right; simpa [Complex.ext_iff] using t_ne_zero
  apply intervalIntegral.integral_deriv_eq_sub'
  ¬∑ exact deriv_fun_re diff
  ¬∑ intro s _
    apply DifferentiableAt.comp
    ¬∑ exact (diff s).restrictScalars ‚Ñù
    ¬∑ exact DifferentiableAt.add_const (c := t * I) <| differentiableAt_ofReal _
  ¬∑ apply ContinuousOn.comp (g := deriv Œ∂) ?_ ?_ (mapsTo_image _ _)
    ¬∑ apply HasDerivAt.continuousOn (f' := deriv <| deriv Œ∂)
      intro x hx
      apply hasDerivAt_deriv_iff.mpr
      replace hx : x ‚â† 1 := by
        contrapose! hx
        simp only [hx, mem_image, Complex.ext_iff, add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im,
          I_im, mul_one, sub_self, add_zero, one_re, add_im, mul_im, zero_add, one_im, not_exists,
          not_and]
        exact fun _ _ _ ‚Ü¶ t_ne_zero
      have := (Complex.analyticAt_iff_eventually_differentiableAt (c := x) (f := Œ∂)).mpr ?_
      ¬∑ obtain ‚ü®r, hr, h‚ü© := this.exists_ball_analyticOn
        apply (h.deriv x ?_).differentiableAt
        simp [hr]
      ¬∑ filter_upwards [compl_singleton_mem_nhds hx] with z hz
        apply differentiableAt_riemannZeta
        simpa [mem_compl_iff, mem_singleton_iff] using hz
    ¬∑ exact ContinuousOn.add continuous_ofReal.continuousOn continuousOn_const
/-%%
\begin{proof}\leanok
This is the fundamental theorem of calculus.
\end{proof}
%%-/

/-%%
\begin{lemma}[Zeta_diff_Bnd]\label{Zeta_diff_Bnd}\lean{Zeta_diff_Bnd}\leanok
For any $A>0$ sufficiently small, there is a constant $C>0$ so that
whenever $1- A / \log t \le \sigma_1 < \sigma_2\le 2$, we have that:
$$
|\zeta (\sigma_2 + it) - \zeta (\sigma_1 + it)|
\le C (\log |t|)^2 (\sigma_2 - \sigma_1).
$$
\end{lemma}
%%-/
lemma Zeta_diff_Bnd :
    ‚àÉ (A : ‚Ñù) (Apos : 0 < A) (C : ‚Ñù) (Cpos : 0 < C), ‚àÄ (œÉ‚ÇÅ œÉ‚ÇÇ : ‚Ñù) (t : ‚Ñù) (t_gt : 3 < |t|)
    (œÉ‚ÇÅ_ge : 1 - A / Real.log |t| ‚â§ œÉ‚ÇÅ) (œÉ‚ÇÇ_le : œÉ‚ÇÇ ‚â§ 2) (œÉ‚ÇÅ_lt_œÉ‚ÇÇ : œÉ‚ÇÅ < œÉ‚ÇÇ),
    ‚ÄñŒ∂ (œÉ‚ÇÇ + t * I) - Œ∂ (œÉ‚ÇÅ + t * I)‚Äñ ‚â§  C * (Real.log |t|) ^ 2 * (œÉ‚ÇÇ - œÉ‚ÇÅ) := by
  obtain ‚ü®A, Apos, C, Cpos, hC‚ü© := ZetaDerivUpperBnd
  refine ‚ü®A, Apos, C, Cpos, ?_‚ü©
  intro œÉ‚ÇÅ œÉ‚ÇÇ t t_gt œÉ‚ÇÅ_ge œÉ‚ÇÇ_le œÉ‚ÇÅ_lt_œÉ‚ÇÇ
  have t_ne_zero : t ‚â† 0 := by contrapose! t_gt; simp only [t_gt, abs_zero, Nat.ofNat_nonneg]
  rw [‚Üê Zeta_eq_int_derivZeta t_ne_zero]
  convert intervalIntegral.norm_integral_le_of_norm_le_const ?_ using 1
  ¬∑ congr; rw [_root_.abs_of_nonneg (by linarith)]
  ¬∑ intro œÉ hœÉ; rw [uIoc_of_le œÉ‚ÇÅ_lt_œÉ‚ÇÇ.le, mem_Ioc] at hœÉ
    exact hC œÉ t t_gt ‚ü®le_trans œÉ‚ÇÅ_ge hœÉ.1.le, le_trans hœÉ.2 œÉ‚ÇÇ_le‚ü©
/-%%
\begin{proof}
\uses{Zeta_eq_int_derivZeta, ZetaDerivUpperBnd}\leanok
Use Lemma \ref{Zeta_eq_int_derivZeta} and
estimate trivially using Lemma \ref{ZetaDerivUpperBnd}.
\end{proof}
%%-/

/-%%
\begin{lemma}[ZetaInvBnd]\label{ZetaInvBnd}\lean{ZetaInvBnd}\leanok
For any $A>0$ sufficiently small, there is a constant $C>0$ so that
whenever $1- A / \log^9 |t| \le \sigma < 1$, we have that:
$$
1/|\zeta(\sigma+it)| \le C \log^7 |t|.
$$
\end{lemma}
%%-/
lemma ZetaInvBnd :
    ‚àÉ (A : ‚Ñù) (Apos : 0 < A) (C : ‚Ñù) (Cpos : 0 < C), ‚àÄ (œÉ : ‚Ñù) (t : ‚Ñù) (t_gt : 3 < |t|)
    (hœÉ : œÉ ‚àà Ico (1 - A / (Real.log |t|) ^ 9) 1),
    1 / ‚ÄñŒ∂ (œÉ + t * I)‚Äñ ‚â§ C * (Real.log |t|) ^ 7 := by
  sorry
/-%%
\begin{proof}
\uses{Zeta_diff_Bnd, ZetaInvBound2}
Let $\sigma$ be given in the prescribed range, and set $\sigma' := 1+ A / \log^9 |t|$.
Then
$$
|\zeta(\sigma+it)| \ge
|\zeta(\sigma'+it)| - |\zeta(\sigma+it) - \zeta(\sigma'+it)|
\ge
C (\sigma'-1)^{-3/4}\log |t|^{-1/4} - C \log^2 |t| (\sigma'-\sigma)
$$
$$
\ge
C A^{-3/4} \log |t|^{-7} - C \log^2 |t| (2 A / \log^9 |t|),
$$
where we used Lemma \ref{ZetaInvBound2}  and Lemma \ref{Zeta_diff_Bnd}.
Now by making $A$ sufficiently small (in particular, something like $A = 1/16$ should work), we can guarantee that
$$
|\zeta(\sigma+it)| \ge \frac C 2 (\log |t|)^{-7},
$$
as desired.
\end{proof}
%%-/

/-%%
\begin{lemma}[LogDerivZetaBnd]\label{LogDerivZetaBnd}\lean{LogDerivZetaBnd}\leanok
There is an $A>0$ so that for $1-A/\log^9 |t| \le \sigma < 1$,
$$
|\frac {\zeta'}{\zeta} (\sigma+it)| \ll \log^9 |t|.
$$
\end{lemma}
%%-/
lemma LogDerivZetaBnd :
    ‚àÉ (A : ‚Ñù) (Apos : 0 < A) (C : ‚Ñù) (Cpos : 0 < C), ‚àÄ (œÉ : ‚Ñù) (t : ‚Ñù) (t_gt : 3 < |t|)
    (hœÉ : œÉ ‚àà Ico (1 - A / (Real.log |t|) ^ 9) 1),
    ‚Äñderiv Œ∂ (œÉ + t * I) / Œ∂ (œÉ + t * I)‚Äñ ‚â§
      C * (Real.log |t|) ^ 9 := by
  obtain ‚ü®A, hA, C, hC, h‚ü© := ZetaInvBnd
  obtain ‚ü®A', hA', C', hC', h'‚ü© := ZetaDerivUpperBnd
  use min A A', lt_min hA hA', C * C', mul_pos hC hC'
  intro œÉ t t_gt ‚ü®œÉ_ge, œÉ_lt‚ü©
  have logt_gt : (1 : ‚Ñù) < Real.log |t| := by
    refine (Real.lt_log_iff_exp_lt (by linarith)).mpr (lt_trans ?_ t_gt)
    exact lt_trans Real.exp_one_lt_d9 (by norm_num)
  have œÉ_ge' : 1 - A / Real.log |t| ^ 9 ‚â§ œÉ := by
    apply le_trans (tsub_le_tsub_left ?_ 1) œÉ_ge
    apply div_le_div hA.le (min_le_left A A') ?_ (by rfl)
    exact pow_pos (lt_trans (by norm_num) logt_gt) 9
  have œÉ_ge'' : 1 - A' / Real.log |t| ‚â§ œÉ := by
    apply le_trans (tsub_le_tsub_left ?_ 1) œÉ_ge
    apply div_le_div hA'.le (min_le_right A A') (lt_trans (by norm_num) logt_gt) ?_
    exact le_self_pow logt_gt.le (by norm_num)
  replace h := h œÉ t t_gt ‚ü®œÉ_ge', œÉ_lt‚ü©
  replace h' := h' œÉ t t_gt ‚ü®œÉ_ge'', by linarith‚ü©
  simp only [norm_div, norm_one, norm_mul, norm_inv]
  convert mul_le_mul h h' (by simp [apply_nonneg]) ?_ using 1 <;> ring_nf
  exact mul_nonneg hC.le <| pow_nonneg (Real.log_nonneg (by linarith)) 7
/-%%
\begin{proof}\leanok
\uses{ZetaInvBnd, ZetaDerivUpperBnd}
Combine the bound on $|\zeta'|$ from Lemma \ref{ZetaDerivUpperBnd} with the bound on $1/|\zeta|$ from Lemma \ref{ZetaInvBnd}.
\end{proof}
%%-/
